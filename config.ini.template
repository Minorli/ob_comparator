# 配置说明：源端用 oracledb，目标端通过 obclient；确保凭据勿入库/勿外泄。
[ORACLE_SOURCE]
# 源端 Oracle 数据库的连接信息
# DSN 格式: "hostname:port/service_name"
user     = your_username
password = your_password
dsn      = hostname:1521/service_name

[OCEANBASE_TARGET]
# 目标端 OceanBase (obclient) 的命令行参数，确保路径/权限正确
executable  = /usr/bin/obclient
host        = 127.0.0.1
port        = 2883
# 完整的 -u 参数，建议使用 SYS
user_string = root@sys#cluster_name
password    = your_password

[SETTINGS]
# 要扫描的所有源端 schema，用逗号分隔，可换行（大小写不敏感）
source_schemas          = ORA_APP,ORA_FIN,ORA_BI
# Remap 规则文件路径（迁移时需要改变 schema 的对象映射）
# 留空表示按 1:1 映射处理
remap_file              = remap_rules.txt

# dbcat 调用的 CLI 超时，单位秒；对象多时可调大
# 建议值：300~1800（视对象数量与网络情况而定）
cli_timeout             = 600
# obclient 调用超时，单位秒；控制元数据/执行脚本超时
# 建议值：60~600（视对象数量与网络情况而定）
obclient_timeout        = 120
# run_fixup 执行 SQL 的超时（秒）；0 表示不设超时
# 建议值：3600（视授权/视图规模调整）
fixup_cli_timeout       = 3600

# 报告与修复脚本输出目录（可为相对路径或绝对路径）
fixup_dir               = fixup_scripts
# fixup_force_clean=true 时，即使 fixup_dir 为项目外绝对路径也会清理旧脚本（谨慎使用）
fixup_force_clean       = true
# fixup_drop_sys_c_columns：是否对目标端额外 SYS_C* 列生成 ALTER TABLE FORCE（默认 false）
fixup_drop_sys_c_columns = false
report_dir              = main_reports
# 报告目录布局：
#   flat    -> 输出到 report_dir 根目录（旧行为）
#   per_run -> 每次运行输出到 report_dir/run_<timestamp>（默认）
report_dir_layout       = per_run
# 报告内容模式：
#   full   -> 主报告包含全部明细
#   split  -> 主报告仅概要，细节拆分到多个 *_detail_*.txt（默认）
#   summary-> 仅输出概要，不生成细节文件
report_detail_mode      = split
# 报告存库（默认开启）
# report_to_db: 是否写入 OceanBase（obclient 方式）
# report_db_schema: 存储 schema（留空使用目标连接用户）
# report_retention_days: 历史保留天数（0 表示不清理）
# report_db_fail_abort: 写库失败是否中止
# report_db_detail_mode: 写入明细范围（missing/mismatched/unsupported/ok/skipped/all）
# report_db_detail_max_rows: 明细最大行数（0 不限制）
# report_db_insert_batch: INSERT ALL 批量大小
# report_db_save_full_json: 是否保存完整 JSON（可能很大）
report_to_db            = true
report_db_schema        =
report_retention_days   = 90
report_db_fail_abort    = false
report_db_detail_mode   = missing,mismatched,unsupported
report_db_detail_max_rows = 500000
report_db_insert_batch  = 200
report_db_save_full_json = false
# 日志目录与级别（日志文件与控制台输出）
# log_level 可选值：AUTO/DEBUG/INFO/WARNING/ERROR/CRITICAL
# AUTO: TTY 使用 INFO，非 TTY 使用 WARNING
log_dir                 = logs
log_level               = auto
# report_width 为报告宽度（避免 nohup 等环境下自动截断）
report_width            = 160

# 修补脚本生成相关
# fixup_workers 控制并发生成脚本的线程数，建议 8 或 12；留空或 0 则自动取 min(12, CPU)
fixup_workers           = 8
# progress_log_interval 控制生成脚本时的进度日志间隔（秒，>=1）
progress_log_interval   = 10
# 扩展对象校验性能调优
# extra_check_workers 控制并发校验进程数，建议 8 或 16；留空或 0 则自动取 min(16, CPU)
extra_check_workers     = 16
# extra_check_chunk_size 控制每个进程一次处理的表数量（默认 200）
extra_check_chunk_size  = 200
# extra_check_progress_interval 控制扩展对象校验的进度日志间隔（秒，>=1）
extra_check_progress_interval = 10
# dbcat 每批对象数量（避免命令行过长，可按需调大）
# 建议值：100~300
dbcat_chunk_size        = 150

# 是否在对比后生成修复脚本（dbcat 抽取，VIEW 走 DBMS_METADATA）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
generate_fixup          = true
# interval 分区补齐脚本（默认开启）
# generate_interval_partition_fixup: true/false
# interval_partition_cutoff: 截止日期，格式 YYYYMMDD（默认 20280301）
generate_interval_partition_fixup = true
interval_partition_cutoff = 20280301
# interval_partition_cutoff_numeric: 数值型 interval 分区补齐上限（仅数值分区键使用），如 100000
interval_partition_cutoff_numeric =
# 是否生成授权脚本并附加到修补 DDL（依赖于源端权限/依赖推导）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
generate_grants         = true
# run_fixup 自动补权限（默认开启）
# fixup_auto_grant: true/false
# fixup_auto_grant_types: 自动补权限对象类型（逗号分隔）
# fixup_auto_grant_fallback: 无匹配授权脚本时是否自动生成 GRANT (true/false)
fixup_auto_grant        = true
fixup_auto_grant_types  = VIEW,MATERIALIZED VIEW,SYNONYM,PROCEDURE,FUNCTION,PACKAGE,PACKAGE BODY,TRIGGER,TYPE,TYPE BODY
fixup_auto_grant_fallback = true
# 授权抽取范围（DBA_TAB_PRIVS）
# owner: 仅加载源 schema 拥有的对象权限（默认，性能更佳）
# owner_or_grantee: 兼容旧逻辑，额外加载 grantee 在源 schema 的对象授权
grant_tab_privs_scope   = owner
# 授权合并（减少 GRANT 语句数量）
# grant_merge_privileges: 合并同一对象的多权限
# grant_merge_grantees: 合并同一权限的多 grantee
grant_merge_privileges  = true
grant_merge_grantees    = true
# 授权兼容过滤（可选覆盖）
# grant_supported_sys_privs: 支持的系统权限清单（逗号分隔，留空自动探测）
# grant_supported_object_privs: 支持的对象权限清单（逗号分隔，留空使用默认）
# grant_include_oracle_maintained_roles: 是否生成 ORACLE_MAINTAINED 角色 (true/false)
grant_supported_sys_privs       = 
grant_supported_object_privs    = 
grant_include_oracle_maintained_roles = false
# 仅生成指定目标 schema/对象类型的修补脚本（留空为全量）
# fixup_schemas 示例：HERO_A,HERO_B
# fixup_types 可选值：
#   TABLE, VIEW, MATERIALIZED VIEW, PROCEDURE, FUNCTION, PACKAGE, PACKAGE BODY,
#   SYNONYM, JOB, SCHEDULE, TYPE, TYPE BODY, SEQUENCE, TRIGGER, INDEX, CONSTRAINT
# 示例：fixup_types=TABLE,TRIGGER
fixup_schemas           = 
fixup_types             = 
# 修补脚本幂等模式（避免重复执行失败）
#   off         -> 不处理（默认）
#   replace     -> 对支持的对象类型使用 CREATE OR REPLACE
#   guard       -> 对不支持 REPLACE 的对象，存在则跳过创建
#   drop_create -> 先判断存在则 DROP，再执行 CREATE
fixup_idempotent_mode   = replace
# 幂等模式作用对象类型（逗号分隔，留空使用默认安全集合）
# 示例：fixup_idempotent_types=TABLE,INDEX,CONSTRAINT
fixup_idempotent_types  =
# 同义词修补范围：
#   all         -> 生成 PUBLIC + 私有同义词（默认）
#   public_only -> 仅生成 PUBLIC 同义词
synonym_fixup_scope     = public_only
# 可选：触发器清单过滤（每行 SCHEMA.TRIGGER_NAME）
# 配置后仅生成列表内触发器脚本，并输出 report_dir/trigger_status_report.txt 记录清单与状态差异
trigger_list            =
# 触发器 DDL 是否强制补全 schema 前缀 (true/false)
trigger_qualify_schema  = true

# 可选：限制本次只检查的对象类型/模块，留空表示全量（大小写不敏感，逗号分隔）
# check_primary_types 可选值：
#   TABLE, VIEW, MATERIALIZED VIEW, PROCEDURE, FUNCTION, PACKAGE, PACKAGE BODY,
#   SYNONYM, JOB, SCHEDULE, TYPE, TYPE BODY
#   注意：MATERIALIZED VIEW 默认仅打印不校验（仍会在报告中展示）
# check_extra_types 可选值：
#   INDEX, CONSTRAINT, SEQUENCE, TRIGGER
# 示例：
#   只检查表 -> check_primary_types=TABLE
#   检查表+视图 -> check_primary_types=TABLE,VIEW
#   只检查扩展序列 -> check_extra_types=SEQUENCE
check_primary_types     =
check_extra_types       = index,constraint,sequence,trigger
# 是否进行依赖关系校验
# 可选值：true/false/1/0/yes/no（大小写不敏感）
check_dependencies      = true
# 是否输出依赖链路拓扑（依赖在前的顺序），用于审计/排查
# 可选值：true/false/1/0/yes/no（大小写不敏感；仅在 check_dependencies=true 时生效）
print_dependency_chains = true
# 是否比对表/列注释 (DBA_TAB_COMMENTS / DBA_COL_COMMENTS)，若元数据权限不足可设为 false
# 可选值：true/false/1/0/yes/no（大小写不敏感）
check_comments          = true
# 是否校验列顺序（仅在启用时比较，默认关闭）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
check_column_order      = false
# 是否校验 VIEW/SYNONYM 可用性（存在但不可用场景）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
check_object_usability  = false
# 是否同时校验源端可用性（用于判断“预期不可用”）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
check_source_usability  = true
# 可用性校验超时（秒，建议 5~30）
usability_check_timeout = 10
# 可用性校验并发线程数
usability_check_workers = 10
# 可用性校验抽样阈值（0 表示不抽样）
max_usability_objects   = 0
# 可用性校验抽样比例（0~1；留空或 0 表示不抽样）
usability_sample_ratio  = 0
# 列可见性(INVISIBLE)处理策略
#   auto    -> 元数据可用时校验并生成修补（默认）
#   enforce -> 强制校验/生成修补（即使元数据不完整）
#   ignore  -> 不校验列可见性
column_visibility_policy = auto
# 黑名单规则来源：
#   auto       -> TMP_BLACK_TABLE + 规则文件（默认）
#   table_only -> 仅使用 TMP_BLACK_TABLE
#   rules_only -> 仅使用规则文件
#   disabled   -> 关闭黑名单过滤
blacklist_mode          = auto
# 黑名单规则文件（JSON），留空使用内置默认
# 注意：blacklist_mode=auto/rules_only 时需保证该文件随工具一同部署，否则规则会被跳过
blacklist_rules_path    = blacklist_rules.json
# 仅启用指定规则（逗号分隔，留空表示全量）
blacklist_rules_enable  =
# 禁用指定规则（逗号分隔）
blacklist_rules_disable =
# LOB 体积阈值（MB）；超过阈值则标记为 LOB_OVERSIZE
blacklist_lob_max_mb    = 512
# 是否启用 schema 推导（一对多场景下用于非表对象）
# 可选值：true/false/1/0/yes/no（大小写不敏感）
infer_schema_mapping    = true
# SEQUENCE 目标 schema 推导策略：
#   infer          -> 依赖推导 + 主流表 schema 推导
#   source_only    -> 始终保持源 schema（默认）
#   dominant_table -> 仅按主流表 schema 推导
sequence_remap_policy   = source_only
# 是否清洗 PL/SQL DDL 中的全角标点（默认开启，避免目标端解析失败）
ddl_punct_sanitize      = true
# DDL hint 清洗策略:
#   drop_all       - 删除全部 hint 注释
#   keep_supported - 保留 OceanBase 支持的 hint (默认)
#   keep_all       - 保留全部 hint (但仍受 denylist 控制)
#   report_only    - 保留全部 hint，仅报告未知 hint
ddl_hint_policy         = keep_supported
# 额外允许的 hint（逗号分隔，大小写不敏感）
ddl_hint_allowlist      =
# 强制删除的 hint（逗号分隔，大小写不敏感）
ddl_hint_denylist       =
# 额外允许 hint 文件（每行一个，# 开头视为注释）
ddl_hint_allowlist_file =
# 是否启用 SQLcl DDL 格式化（后处理，不影响校验/修补逻辑）
ddl_format_enable      = false
# 格式化器 (sqlcl/none)
ddl_formatter          = sqlcl
# 需要格式化的对象类型列表（逗号分隔，留空表示默认 VIEW）
ddl_format_types       =
# SQLcl 根目录或 bin/sql 路径（开启格式化必填）
sqlcl_bin              =
# SQLcl 格式化规则文件（可选）
sqlcl_profile_path     =
# 格式化失败策略：fallback/error
ddl_format_fail_policy = fallback
# SQLcl 批量格式化对象数
ddl_format_batch_size  = 200
# SQLcl 批次超时（秒，0 表示不设超时）
ddl_format_timeout     = 60
# 单个 DDL 最大行数（超过则跳过，0 表示不限制）
ddl_format_max_lines   = 30000
# 单个 DDL 最大字节数（超过则跳过，0 表示不限制）
ddl_format_max_bytes   = 2000000
# 视图兼容性规则 JSON 路径（可选，留空使用内置规则）
view_compat_rules_path  =
# 视图 DBLINK 处理策略：
#   block -> 遇到 @ 视为不支持
#   allow -> 允许 DBLINK
view_dblink_policy      = block
# VIEW 列清单约束清洗策略：
#   auto  -> 仅清洗 RELY DISABLE / DISABLE / NOVALIDATE
#   force -> 强制清洗所有列清单约束
#   off   -> 不清洗（视为不支持）
view_constraint_cleanup = auto
# Oracle Instant Client 目录 (必须包含 libclntsh.so)
oracle_client_lib_dir   = /path/to/instantclient_19_29

# dbcat 配置：需预先设置好 JAVA_HOME；from/to 影响转换逻辑
# dbcat_parallel_workers 为并发线程数（>=1）
dbcat_parallel_workers = 4
# dbcat_bin 为 dbcat 安装目录或可执行文件路径
dbcat_bin               = /path/to/dbcat-2.5.0-SNAPSHOT
# dbcat_output_dir 为 dbcat 输出目录（可相对/绝对）
dbcat_output_dir        = dbcat_output
# dbcat_from/dbcat_to 为 dbcat profile（依 dbcat 版本可选）
dbcat_from              = oracle19c
dbcat_to                = oboracle422
# dbcat_no_cal_dep: 禁用依赖计算以加速抽取（true/false）
dbcat_no_cal_dep        = false
# dbcat_query_meta_thread: 元数据查询线程数（>=1，留空/0 则关闭）
dbcat_query_meta_thread = 0
# dbcat_progress_interval: 进度心跳间隔（秒，<=0 关闭）
dbcat_progress_interval = 15
# cache_parallel_workers: 缓存读取并发（>=1）
cache_parallel_workers  = 1
# dbcat_cleanup_run_dirs: 是否清理每次运行的 dbcat 临时目录（true/false）
dbcat_cleanup_run_dirs  = true
# JAVA_HOME 路径（dbcat 需要）
java_home               =
