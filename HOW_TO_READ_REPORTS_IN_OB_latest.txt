============================================================
OceanBase 报告库排查手册（report_to_db）
文件: HOW_TO_READ_REPORTS_IN_OB_latest.txt
快照: HOW_TO_READ_REPORTS_IN_OB_20260212_15_sqls.txt
============================================================

使用说明
- 将 `:report_id` 替换为目标报告 ID（例如 `20260206_154154_61d1740b`）。
- 先跑 SQL-01/02 找到 report_id，再按“汇总 -> 不支持/阻断 -> 缺失/不一致 -> 依赖/remap -> 授权/可用性”顺序排查。
- `DIFF_REPORT_DETAIL_ITEM` 是“行化细节表”，同一对象出现多行是正常设计（item_type 不同，如 REASON_CODE/ACTION/DEPENDENCY/DETAIL/ROOT_CAUSE）。
- 若某表不存在，请先确认 `report_db_store_scope`：
  - `summary`: 仅 SUMMARY/COUNTS
  - `core`: + DETAIL/GRANT/USABILITY/PACKAGE_COMPARE/TRIGGER_STATUS + 6个分析视图
  - `full`: + DETAIL_ITEM/ARTIFACT/ARTIFACT_LINE/DEPENDENCY/VIEW_CHAIN/REMAP_CONFLICT/OBJECT_MAPPING/BLACKLIST/FIXUP_SKIP/OMS_MISSING

------------------------------------------------------------
L0. 快速入口（新手只看这 12 条）
------------------------------------------------------------

固定顺序（建议直接照抄执行）：
1) SQL-01, SQL-02：确认本次 `report_id`
2) SQL-08, SQL-10：看总体差异面
3) SQL-26, SQL-27：看不支持/阻断原因
4) SQL-16, SQL-37：看缺失与不一致主类型
5) SQL-60, SQL-61, SQL-62, SQL-63：看权限缺失/不一致/不支持
6) SQL-67：看 VIEW/SYNONYM 可用性
7) SQL-47：看依赖边状态分布

------------------------------------------------------------
L1. 场景剧本（按问题类型排查）
------------------------------------------------------------

剧本 A：为什么“缺失很多”
- SQL-10 -> SQL-16 -> SQL-17 -> SQL-21 -> SQL-23

剧本 B：为什么“不可支持对象很多”
- SQL-26 -> SQL-27 -> SQL-28 -> SQL-29 -> SQL-32 -> SQL-33

剧本 C：为什么“多余对象很多（extra）”
- SQL-11 -> SQL-74 -> SQL-75 -> SQL-76 -> SQL-77

剧本 D：为什么“视图/同义词不可用”
- SQL-67 -> SQL-52 -> SQL-53 -> SQL-54 -> SQL-47

剧本 E：为什么“授权问题导致失败”
- SQL-60 -> SQL-61 -> SQL-62 -> SQL-63 -> SQL-64

------------------------------------------------------------
L2. 全量 SQL 索引（A ~ G，保留全部）
------------------------------------------------------------

------------------------------------------------------------
A. 入口与覆盖范围（SQL-01 ~ SQL-14）
------------------------------------------------------------

-- SQL-01 最近10次运行（入口）
SELECT report_id, run_timestamp, conclusion, conclusion_detail, run_dir
  FROM DIFF_REPORT_SUMMARY
 ORDER BY run_timestamp DESC
 FETCH FIRST 10 ROWS ONLY;

-- SQL-02 最新 report_id（单值）
SELECT report_id
  FROM DIFF_REPORT_SUMMARY
 ORDER BY run_timestamp DESC
 FETCH FIRST 1 ROW ONLY;

-- SQL-03 最近7天按结论统计
SELECT conclusion, COUNT(*) AS cnt
  FROM DIFF_REPORT_SUMMARY
 WHERE run_timestamp >= SYSTIMESTAMP - INTERVAL '7' DAY
 GROUP BY conclusion
 ORDER BY cnt DESC;

-- SQL-04 最近7天运行明细（时间窗）
SELECT report_id, run_timestamp, duration_seconds,
       total_checked, missing_count, mismatched_count, unsupported_count,
       conclusion
  FROM DIFF_REPORT_SUMMARY
 WHERE run_timestamp >= SYSTIMESTAMP - INTERVAL '7' DAY
 ORDER BY run_timestamp DESC;

-- SQL-05 指定 report_id 的 DB 覆盖范围（哪些工件入库）
SELECT artifact_type, status, note, row_count, file_path
  FROM DIFF_REPORT_ARTIFACT
 WHERE report_id = :report_id
 ORDER BY artifact_type, status;

-- SQL-06 指定 report_id 的“未入库/部分入库”提醒
SELECT artifact_type, status, note, file_path
  FROM DIFF_REPORT_ARTIFACT
 WHERE report_id = :report_id
   AND status IN ('TXT_ONLY', 'PARTIAL', 'FAILED', 'SKIPPED')
 ORDER BY artifact_type;

-- SQL-07 指定 report_id 的核心表行数体检
SELECT 'DETAIL' AS table_name, COUNT(*) AS cnt FROM DIFF_REPORT_DETAIL WHERE report_id = :report_id
UNION ALL
SELECT 'DETAIL_ITEM', COUNT(*) FROM DIFF_REPORT_DETAIL_ITEM WHERE report_id = :report_id
UNION ALL
SELECT 'COUNTS', COUNT(*) FROM DIFF_REPORT_COUNTS WHERE report_id = :report_id
UNION ALL
SELECT 'GRANT', COUNT(*) FROM DIFF_REPORT_GRANT WHERE report_id = :report_id
UNION ALL
SELECT 'USABILITY', COUNT(*) FROM DIFF_REPORT_USABILITY WHERE report_id = :report_id
UNION ALL
SELECT 'PACKAGE_COMPARE', COUNT(*) FROM DIFF_REPORT_PACKAGE_COMPARE WHERE report_id = :report_id
UNION ALL
SELECT 'TRIGGER_STATUS', COUNT(*) FROM DIFF_REPORT_TRIGGER_STATUS WHERE report_id = :report_id
UNION ALL
SELECT 'ARTIFACT', COUNT(*) FROM DIFF_REPORT_ARTIFACT WHERE report_id = :report_id
UNION ALL
SELECT 'ARTIFACT_LINE', COUNT(*) FROM DIFF_REPORT_ARTIFACT_LINE WHERE report_id = :report_id
UNION ALL
SELECT 'DEPENDENCY', COUNT(*) FROM DIFF_REPORT_DEPENDENCY WHERE report_id = :report_id
UNION ALL
SELECT 'VIEW_CHAIN', COUNT(*) FROM DIFF_REPORT_VIEW_CHAIN WHERE report_id = :report_id;

-- SQL-08 指定 report_id 的主汇总（检查汇总同源）
SELECT report_id, run_timestamp, duration_seconds,
       total_checked, missing_count, mismatched_count, unsupported_count, skipped_count,
       index_missing, index_mismatched,
       constraint_missing, constraint_mismatch,
       trigger_missing, sequence_missing,
       detail_truncated, detail_truncated_count,
       conclusion, conclusion_detail
  FROM DIFF_REPORT_SUMMARY
 WHERE report_id = :report_id;

-- SQL-09 指定 report_id 的问题率（缺失/不支持/不一致）
SELECT report_id,
       total_checked,
       ROUND(100 * missing_count / NULLIF(total_checked, 0), 2) AS missing_pct,
       ROUND(100 * unsupported_count / NULLIF(total_checked, 0), 2) AS unsupported_pct,
       ROUND(100 * mismatched_count / NULLIF(total_checked, 0), 2) AS mismatched_pct
  FROM DIFF_REPORT_SUMMARY
 WHERE report_id = :report_id;

-- SQL-10 按对象类型汇总（Oracle vs OB vs 差异）
SELECT object_type, oracle_count, oceanbase_count,
       missing_count, unsupported_count, extra_count
  FROM DIFF_REPORT_COUNTS
 WHERE report_id = :report_id
 ORDER BY unsupported_count DESC, missing_count DESC, extra_count DESC, object_type;

-- SQL-11 问题对象类型排名（missing+unsupported+extra）
SELECT object_type,
       (missing_count + unsupported_count + extra_count) AS total_gap,
       missing_count, unsupported_count, extra_count
  FROM DIFF_REPORT_COUNTS
 WHERE report_id = :report_id
 ORDER BY total_gap DESC, object_type;

-- SQL-12 仅显示有差异的对象类型
SELECT object_type,
       oracle_count, oceanbase_count,
       missing_count, unsupported_count, extra_count
  FROM DIFF_REPORT_COUNTS
 WHERE report_id = :report_id
   AND (missing_count > 0 OR unsupported_count > 0 OR extra_count > 0)
 ORDER BY object_type;

-- SQL-13 schema + object_type 矩阵（缺失/不支持/不一致）
SELECT NVL(source_schema, target_schema) AS schema_name,
       object_type,
       SUM(CASE WHEN report_type = 'MISSING' THEN 1 ELSE 0 END) AS missing_cnt,
       SUM(CASE WHEN report_type = 'UNSUPPORTED' THEN 1 ELSE 0 END) AS unsupported_cnt,
       SUM(CASE WHEN report_type = 'MISMATCHED' THEN 1 ELSE 0 END) AS mismatched_cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
 GROUP BY NVL(source_schema, target_schema), object_type
 ORDER BY schema_name, object_type;

-- SQL-14 问题 schema Top20
SELECT NVL(source_schema, target_schema) AS schema_name,
       COUNT(*) AS issue_cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type IN ('MISSING', 'UNSUPPORTED', 'MISMATCHED')
 GROUP BY NVL(source_schema, target_schema)
 ORDER BY issue_cnt DESC, schema_name
 FETCH FIRST 20 ROWS ONLY;

------------------------------------------------------------
B. 缺失对象（SQL-15 ~ SQL-24）
------------------------------------------------------------

-- SQL-15 缺失对象明细
SELECT object_type, source_schema, source_name, target_schema, target_name, status, reason
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISSING'
 ORDER BY object_type, source_schema, source_name;

-- SQL-16 缺失对象按类型统计
SELECT object_type, COUNT(*) AS missing_cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISSING'
 GROUP BY object_type
 ORDER BY missing_cnt DESC, object_type;

-- SQL-17 缺失对象按 schema 统计
SELECT NVL(source_schema, target_schema) AS schema_name,
       COUNT(*) AS missing_cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISSING'
 GROUP BY NVL(source_schema, target_schema)
 ORDER BY missing_cnt DESC, schema_name;

-- SQL-18 缺失中的 TABLE/VIEW（迁移高频）
SELECT object_type, source_schema, source_name, target_schema, target_name, reason
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISSING'
   AND object_type IN ('TABLE', 'VIEW')
 ORDER BY object_type, source_schema, source_name;

-- SQL-19 缺失对象 + remap 映射信息
SELECT d.object_type,
       d.source_schema, d.source_name,
       d.target_schema, d.target_name,
       m.map_source,
       d.reason
  FROM DIFF_REPORT_DETAIL d
  LEFT JOIN DIFF_REPORT_OBJECT_MAPPING m
    ON m.report_id = d.report_id
   AND m.object_type = d.object_type
   AND m.src_schema = d.source_schema
   AND m.src_name = d.source_name
 WHERE d.report_id = :report_id
   AND d.report_type = 'MISSING'
 ORDER BY d.object_type, d.source_schema, d.source_name;

-- SQL-20 OMS 关注的缺失清单
SELECT object_type, target_schema,
       src_schema, src_name,
       tgt_schema, tgt_name
  FROM DIFF_REPORT_OMS_MISSING
 WHERE report_id = :report_id
 ORDER BY object_type, target_schema, src_schema, src_name;

-- SQL-21 fixup 跳过汇总（按对象类型/原因）
SELECT object_type, missing_total, task_total, generated_total,
       skip_reason, skip_count
  FROM DIFF_REPORT_FIXUP_SKIP
 WHERE report_id = :report_id
 ORDER BY object_type, skip_count DESC, skip_reason;

-- SQL-22 缺失对象与 fixup 跳过原因关联（粗粒度）
SELECT d.object_type,
       COUNT(*) AS missing_cnt,
       NVL(s.skip_reason, '-') AS skip_reason,
       NVL(s.skip_count, 0) AS skip_count
  FROM DIFF_REPORT_DETAIL d
  LEFT JOIN DIFF_REPORT_FIXUP_SKIP s
    ON s.report_id = d.report_id
   AND s.object_type = d.object_type
 WHERE d.report_id = :report_id
   AND d.report_type = 'MISSING'
 GROUP BY d.object_type, NVL(s.skip_reason, '-'), NVL(s.skip_count, 0)
 ORDER BY d.object_type, skip_count DESC;

-- SQL-23 缺失对象对应动作（FIXUP/REFACTOR/DEPENDENCY/GRANT_REQUIRED）
SELECT a.action_type, a.object_type, a.schema_name, a.object_name, a.reason
  FROM DIFF_REPORT_ACTIONS_V a
 WHERE a.report_id = :report_id
   AND a.report_type IN ('MISSING', 'MISMATCHED')
 ORDER BY a.action_type, a.object_type, a.schema_name, a.object_name;

-- SQL-24 缺失对象中“需要先补权限”的候选
SELECT DISTINCT d.object_type,
       d.target_schema, d.target_name,
       g.grantee, g.privilege, g.with_grant_option
  FROM DIFF_REPORT_DETAIL d
  JOIN DIFF_REPORT_GRANT g
    ON g.report_id = d.report_id
   AND g.status = 'MISSING'
   AND g.target_schema = d.target_schema
   AND g.target_name = d.target_name
 WHERE d.report_id = :report_id
   AND d.report_type = 'MISSING'
 ORDER BY d.object_type, d.target_schema, d.target_name;

C. 不支持/阻断/待确认（SQL-25 ~ SQL-35）
------------------------------------------------------------

-- SQL-25 不支持/阻断/待确认明细
SELECT object_type, source_schema, source_name, target_schema, target_name,
       status, reason
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
 ORDER BY object_type, source_schema, source_name;

-- SQL-26 不支持状态分布（UNSUPPORTED / BLOCKED / RISKY）
SELECT status, COUNT(*) AS cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
 GROUP BY status
 ORDER BY cnt DESC;

-- SQL-27 不支持原因 Top30
SELECT object_type, reason, COUNT(*) AS cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
 GROUP BY object_type, reason
 ORDER BY cnt DESC
 FETCH FIRST 30 ROWS ONLY;

-- SQL-28 不支持对象的 reason_code（行化）
SELECT object_type, source_schema, source_name, target_schema, target_name,
       item_value AS reason_code
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
   AND item_type = 'REASON_CODE'
 ORDER BY object_type, source_schema, source_name;

-- SQL-29 不支持对象的建议动作（行化）
SELECT object_type, source_schema, source_name, target_schema, target_name,
       item_value AS action_suggestion
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
   AND item_type = 'ACTION'
 ORDER BY object_type, source_schema, source_name;

-- SQL-30 不支持对象的依赖对象（行化）
SELECT object_type, source_schema, source_name, target_schema, target_name,
       item_value AS dependency
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
   AND item_type = 'DEPENDENCY'
 ORDER BY object_type, source_schema, source_name;

-- SQL-31 不支持对象的根因（行化）
SELECT object_type, source_schema, source_name, target_schema, target_name,
       item_value AS root_cause
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
   AND item_type = 'ROOT_CAUSE'
 ORDER BY object_type, source_schema, source_name;

-- SQL-32 不支持对象与黑名单表关联
SELECT d.object_type,
       d.source_schema, d.source_name,
       b.black_type, b.data_type, b.reason AS blacklist_reason,
       d.reason AS detail_reason
  FROM DIFF_REPORT_DETAIL d
  JOIN DIFF_REPORT_BLACKLIST b
    ON b.report_id = d.report_id
   AND b.schema_name = d.source_schema
   AND b.table_name = d.source_name
 WHERE d.report_id = :report_id
   AND d.report_type = 'UNSUPPORTED'
 ORDER BY d.object_type, d.source_schema, d.source_name;

-- SQL-33 黑名单汇总（按 BLACK_TYPE）
SELECT black_type,
       COUNT(*) AS table_cnt,
       SUM(CASE WHEN status = 'UNSUPPORTED' THEN 1 ELSE 0 END) AS unsupported_cnt,
       SUM(CASE WHEN status <> 'UNSUPPORTED' OR status IS NULL THEN 1 ELSE 0 END) AS converted_or_other_cnt
  FROM DIFF_REPORT_BLACKLIST
 WHERE report_id = :report_id
 GROUP BY black_type
 ORDER BY table_cnt DESC, black_type;

-- SQL-34 黑名单明细（按状态）
SELECT schema_name, table_name, black_type, data_type, status, reason, detail
  FROM DIFF_REPORT_BLACKLIST
 WHERE report_id = :report_id
 ORDER BY status, black_type, schema_name, table_name;

-- SQL-35 名称规则黑名单（如 _RENAME）
SELECT schema_name, table_name, black_type, status, reason, detail
  FROM DIFF_REPORT_BLACKLIST
 WHERE report_id = :report_id
   AND black_type = 'NAME_PATTERN'
 ORDER BY schema_name, table_name;

-- SQL-35A 显式排除对象（exclude_objects_file）汇总
SELECT status,
       object_type,
       COUNT(*) AS cnt
  FROM DIFF_REPORT_EXCLUDED_OBJECT
 WHERE report_id = :report_id
 GROUP BY status, object_type
 ORDER BY status, object_type;

-- SQL-35B 显式排除对象（exclude_objects_file）明细
SELECT status, line_no, object_type, schema_name, object_name, detail
  FROM DIFF_REPORT_EXCLUDED_OBJECT
 WHERE report_id = :report_id
 ORDER BY line_no, status, object_type, schema_name, object_name;

------------------------------------------------------------
D. 不一致（MISMATCHED）深挖（SQL-36 ~ SQL-46）
------------------------------------------------------------

-- SQL-36 不一致对象明细
SELECT object_type, source_schema, source_name, target_schema, target_name, reason
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
 ORDER BY object_type, target_schema, target_name;

-- SQL-37 不一致对象按类型统计
SELECT object_type, COUNT(*) AS mismatch_cnt
  FROM DIFF_REPORT_DETAIL
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
 GROUP BY object_type
 ORDER BY mismatch_cnt DESC, object_type;

-- SQL-38 TABLE: 缺列/多列
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TABLE'
   AND item_type IN ('MISSING_COLUMN', 'EXTRA_COLUMN')
 ORDER BY source_schema, source_name, item_type, item_key;

-- SQL-39 TABLE: 类型不一致
SELECT source_schema, source_name, target_schema, target_name,
       item_key AS column_name,
       src_value AS src_type,
       tgt_value AS tgt_type,
       item_value AS rule_info
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TABLE'
   AND item_type = 'TYPE_MISMATCH'
 ORDER BY source_schema, source_name, item_key;

-- SQL-40 TABLE: 长度不一致
SELECT source_schema, source_name, target_schema, target_name,
       item_key AS column_name,
       src_value AS src_length,
       tgt_value AS tgt_length,
       item_value AS rule_info
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TABLE'
   AND item_type = 'LENGTH_MISMATCH'
 ORDER BY source_schema, source_name, item_key;

-- SQL-41 INDEX: 缺失/多余/细节
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key, item_value
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'INDEX'
 ORDER BY source_schema, source_name, item_type, item_key;

-- SQL-42 CONSTRAINT: 缺失/多余/降级PK/细节
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key, item_value
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'CONSTRAINT'
 ORDER BY source_schema, source_name, item_type, item_key;

-- SQL-43 SEQUENCE: 缺失/多余/映射/细节
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key, item_value
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'SEQUENCE'
 ORDER BY source_schema, source_name, item_type, item_key;

-- SQL-44 TRIGGER: 缺失/多余/细节
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key, item_value
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TRIGGER'
 ORDER BY source_schema, source_name, item_type, item_key;

-- SQL-45 SYS_C 特殊列候选（预期走 ALTER TABLE ... FORCE）
SELECT source_schema, source_name, target_schema, target_name,
       item_type, item_key
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TABLE'
   AND item_type = 'EXTRA_COLUMN'
   AND UPPER(item_key) LIKE 'SYS_C%$'
 ORDER BY source_schema, source_name, item_key;

-- SQL-46 NUMBER 精度相关疑似噪声（快速筛查）
SELECT source_schema, source_name, target_schema, target_name,
       item_key, src_value, tgt_value, item_value
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'MISMATCHED'
   AND object_type = 'TABLE'
   AND item_type = 'TYPE_MISMATCH'
   AND (UPPER(NVL(src_value, '')) LIKE '%NUMBER%'
        OR UPPER(NVL(tgt_value, '')) LIKE '%NUMBER%'
        OR UPPER(NVL(item_value, '')) LIKE '%NUMBER%')
 ORDER BY source_schema, source_name, item_key;

------------------------------------------------------------
E. 依赖 / 视图链 / remap 专项（SQL-47 ~ SQL-59）
------------------------------------------------------------

-- SQL-47 依赖边状态分布
SELECT edge_status, COUNT(*) AS cnt
  FROM DIFF_REPORT_DEPENDENCY
 WHERE report_id = :report_id
 GROUP BY edge_status
 ORDER BY cnt DESC, edge_status;

-- SQL-48 缺失依赖边
SELECT dep_schema, dep_name, dep_type,
       ref_schema, ref_name, ref_type,
       reason
  FROM DIFF_REPORT_DEPENDENCY
 WHERE report_id = :report_id
   AND edge_status = 'MISSING'
 ORDER BY dep_type, dep_schema, dep_name, ref_type, ref_schema, ref_name;

-- SQL-49 跳过依赖边
SELECT dep_schema, dep_name, dep_type,
       ref_schema, ref_name, ref_type,
       reason
  FROM DIFF_REPORT_DEPENDENCY
 WHERE report_id = :report_id
   AND edge_status = 'SKIPPED'
 ORDER BY dep_type, dep_schema, dep_name;

-- SQL-50 多余依赖边（UNEXPECTED）
SELECT dep_schema, dep_name, dep_type,
       ref_schema, ref_name, ref_type,
       reason
  FROM DIFF_REPORT_DEPENDENCY
 WHERE report_id = :report_id
   AND edge_status = 'UNEXPECTED'
 ORDER BY dep_type, dep_schema, dep_name;

-- SQL-51 期望依赖边总量（基线）
SELECT COUNT(*) AS expected_edges
  FROM DIFF_REPORT_DEPENDENCY
 WHERE report_id = :report_id
   AND edge_status = 'EXPECTED';

-- SQL-52 VIEW 链中“节点不存在”
SELECT view_schema, view_name, chain_id, node_index,
       node_schema, node_name, node_type, node_exists, grant_status, cycle_flag
  FROM DIFF_REPORT_VIEW_CHAIN
 WHERE report_id = :report_id
   AND NVL(node_exists, 'UNKNOWN') <> 'EXISTS'
 ORDER BY view_schema, view_name, chain_id, node_index;

-- SQL-53 VIEW 链中“授权缺失”
SELECT view_schema, view_name, chain_id, node_index,
       node_schema, node_name, node_type, node_exists, grant_status, cycle_flag
  FROM DIFF_REPORT_VIEW_CHAIN
 WHERE report_id = :report_id
   AND UPPER(NVL(grant_status, '')) LIKE 'GRANT_MISSING%'
 ORDER BY view_schema, view_name, chain_id, node_index;

-- SQL-54 VIEW 链循环
SELECT view_schema, view_name, chain_id,
       COUNT(*) AS cycle_nodes
  FROM DIFF_REPORT_VIEW_CHAIN
 WHERE report_id = :report_id
   AND cycle_flag = 1
 GROUP BY view_schema, view_name, chain_id
 ORDER BY cycle_nodes DESC, view_schema, view_name, chain_id;

-- SQL-55 remap 冲突明细
SELECT object_type, source_schema, source_name, reason, candidates
  FROM DIFF_REPORT_REMAP_CONFLICT
 WHERE report_id = :report_id
 ORDER BY object_type, source_schema, source_name;

-- SQL-56 映射来源分布（identity/rule/inferred）
SELECT map_source, COUNT(*) AS cnt
  FROM DIFF_REPORT_OBJECT_MAPPING
 WHERE report_id = :report_id
 GROUP BY map_source
 ORDER BY cnt DESC, map_source;

-- SQL-57 一个源对象映射到多个目标（潜在歧义）
SELECT src_schema, src_name, object_type,
       COUNT(DISTINCT tgt_schema || '.' || tgt_name) AS tgt_cnt
  FROM DIFF_REPORT_OBJECT_MAPPING
 WHERE report_id = :report_id
 GROUP BY src_schema, src_name, object_type
HAVING COUNT(DISTINCT tgt_schema || '.' || tgt_name) > 1
 ORDER BY tgt_cnt DESC, src_schema, src_name, object_type;

-- SQL-58 多个源对象映射到同一目标（潜在碰撞）
SELECT tgt_schema, tgt_name, object_type,
       COUNT(DISTINCT src_schema || '.' || src_name) AS src_cnt
  FROM DIFF_REPORT_OBJECT_MAPPING
 WHERE report_id = :report_id
 GROUP BY tgt_schema, tgt_name, object_type
HAVING COUNT(DISTINCT src_schema || '.' || src_name) > 1
 ORDER BY src_cnt DESC, tgt_schema, tgt_name, object_type;

-- SQL-59 PUBLIC/__public 相关映射检查（同义词常见）
SELECT src_schema, src_name, object_type,
       tgt_schema, tgt_name, map_source
  FROM DIFF_REPORT_OBJECT_MAPPING
 WHERE report_id = :report_id
   AND (UPPER(src_schema) = 'PUBLIC' OR tgt_schema = '__public')
 ORDER BY object_type, src_schema, src_name;

------------------------------------------------------------
F. 授权 / 可用性 / 包 / 触发器 / 写库异常（SQL-60 ~ SQL-73）
------------------------------------------------------------

-- SQL-60 GRANT 三分类汇总（缺失 / 缺选项 / 不支持）
WITH g AS (
    SELECT *
      FROM DIFF_REPORT_GRANT
     WHERE report_id = :report_id
),
planned AS (
    SELECT *
      FROM g
     WHERE status = 'PLANNED'
),
filtered AS (
    SELECT *
      FROM g
     WHERE status = 'FILTERED'
),
obj_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           UPPER(owner) AS owner,
           UPPER(table_name) AS table_name,
           MAX(CASE WHEN UPPER(NVL(grantable, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_wgo
      FROM dba_tab_privs
     GROUP BY UPPER(grantee), UPPER(privilege), UPPER(owner), UPPER(table_name)
),
sys_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_sys_privs
     GROUP BY UPPER(grantee), UPPER(privilege)
),
role_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(granted_role) AS granted_role,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_role_privs
     GROUP BY UPPER(grantee), UPPER(granted_role)
),
diag AS (
    SELECT p.grant_type,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_wgo = 0 THEN 'MISSING_WITH_GRANT_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN obj_now n
        ON p.grant_type = 'OBJECT'
       AND n.grantee = UPPER(p.grantee)
       AND n.privilege = UPPER(p.privilege)
       AND n.owner = UPPER(NVL(p.target_schema, ''))
       AND n.table_name = UPPER(NVL(p.target_name, ''))
    UNION ALL
    SELECT p.grant_type,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_admin = 0 THEN 'MISSING_WITH_ADMIN_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN sys_now n
        ON p.grant_type = 'SYSTEM'
       AND n.grantee = UPPER(p.grantee)
       AND n.privilege = UPPER(p.privilege)
    UNION ALL
    SELECT p.grant_type,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_admin = 0 THEN 'MISSING_WITH_ADMIN_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN role_now n
        ON p.grant_type = 'ROLE'
       AND n.grantee = UPPER(p.grantee)
       AND n.granted_role = UPPER(p.privilege)
),
merged AS (
    SELECT grant_type, diagnose FROM diag
    UNION ALL
    SELECT grant_type, 'UNSUPPORTED_FILTERED' AS diagnose FROM filtered
)
SELECT grant_type, diagnose, COUNT(*) AS cnt
  FROM merged
 GROUP BY grant_type, diagnose
 ORDER BY grant_type, cnt DESC, diagnose;

-- SQL-61 缺失授权明细（目标端完全不存在）
WITH g AS (
    SELECT *
      FROM DIFF_REPORT_GRANT
     WHERE report_id = :report_id
       AND status = 'PLANNED'
),
obj_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           UPPER(owner) AS owner,
           UPPER(table_name) AS table_name
      FROM dba_tab_privs
     GROUP BY UPPER(grantee), UPPER(privilege), UPPER(owner), UPPER(table_name)
),
sys_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege
      FROM dba_sys_privs
     GROUP BY UPPER(grantee), UPPER(privilege)
),
role_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(granted_role) AS granted_role
      FROM dba_role_privs
     GROUP BY UPPER(grantee), UPPER(granted_role)
)
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       p.with_grant_option, p.status
  FROM g p
  LEFT JOIN obj_now n
    ON p.grant_type = 'OBJECT'
   AND n.grantee = UPPER(p.grantee)
   AND n.privilege = UPPER(p.privilege)
   AND n.owner = UPPER(NVL(p.target_schema, ''))
   AND n.table_name = UPPER(NVL(p.target_name, ''))
 WHERE p.grant_type = 'OBJECT'
   AND n.grantee IS NULL
UNION ALL
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       p.with_grant_option, p.status
  FROM g p
  LEFT JOIN sys_now n
    ON p.grant_type = 'SYSTEM'
   AND n.grantee = UPPER(p.grantee)
   AND n.privilege = UPPER(p.privilege)
 WHERE p.grant_type = 'SYSTEM'
   AND n.grantee IS NULL
UNION ALL
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       p.with_grant_option, p.status
  FROM g p
  LEFT JOIN role_now n
    ON p.grant_type = 'ROLE'
   AND n.grantee = UPPER(p.grantee)
   AND n.granted_role = UPPER(p.privilege)
 WHERE p.grant_type = 'ROLE'
   AND n.grantee IS NULL
ORDER BY grant_type, grantee, target_schema, target_name, privilege;

-- SQL-62 权限不一致明细（已存在但缺少 WITH GRANT/ADMIN OPTION）
WITH g AS (
    SELECT *
      FROM DIFF_REPORT_GRANT
     WHERE report_id = :report_id
       AND status = 'PLANNED'
       AND with_grant_option = 1
),
obj_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           UPPER(owner) AS owner,
           UPPER(table_name) AS table_name,
           MAX(CASE WHEN UPPER(NVL(grantable, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_wgo
      FROM dba_tab_privs
     GROUP BY UPPER(grantee), UPPER(privilege), UPPER(owner), UPPER(table_name)
),
sys_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_sys_privs
     GROUP BY UPPER(grantee), UPPER(privilege)
),
role_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(granted_role) AS granted_role,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_role_privs
     GROUP BY UPPER(grantee), UPPER(granted_role)
)
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       'MISSING_WITH_GRANT_OPTION' AS mismatch_type
  FROM g p
  JOIN obj_now n
    ON p.grant_type = 'OBJECT'
   AND n.grantee = UPPER(p.grantee)
   AND n.privilege = UPPER(p.privilege)
   AND n.owner = UPPER(NVL(p.target_schema, ''))
   AND n.table_name = UPPER(NVL(p.target_name, ''))
 WHERE n.has_wgo = 0
UNION ALL
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       'MISSING_WITH_ADMIN_OPTION' AS mismatch_type
  FROM g p
  JOIN sys_now n
    ON p.grant_type = 'SYSTEM'
   AND n.grantee = UPPER(p.grantee)
   AND n.privilege = UPPER(p.privilege)
 WHERE n.has_admin = 0
UNION ALL
SELECT p.grant_type, p.grantee, p.privilege,
       p.target_schema, p.target_name, p.target_type,
       'MISSING_WITH_ADMIN_OPTION' AS mismatch_type
  FROM g p
  JOIN role_now n
    ON p.grant_type = 'ROLE'
   AND n.grantee = UPPER(p.grantee)
   AND n.granted_role = UPPER(p.privilege)
 WHERE n.has_admin = 0
ORDER BY grant_type, grantee, target_schema, target_name, privilege;

-- SQL-63 被过滤授权及原因（= 不支持或策略过滤）
SELECT grant_type, grantee, privilege,
       target_schema, target_name, target_type,
       status, filter_reason
  FROM DIFF_REPORT_GRANT
 WHERE report_id = :report_id
   AND status = 'FILTERED'
 ORDER BY filter_reason, grant_type, grantee, target_schema, target_name;

-- SQL-64 授权热点（按 grantee，分缺失/缺选项/不支持）
WITH g AS (
    SELECT *
      FROM DIFF_REPORT_GRANT
     WHERE report_id = :report_id
),
planned AS (
    SELECT *
      FROM g
     WHERE status = 'PLANNED'
),
filtered AS (
    SELECT grant_type, grantee
      FROM g
     WHERE status = 'FILTERED'
),
obj_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           UPPER(owner) AS owner,
           UPPER(table_name) AS table_name,
           MAX(CASE WHEN UPPER(NVL(grantable, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_wgo
      FROM dba_tab_privs
     GROUP BY UPPER(grantee), UPPER(privilege), UPPER(owner), UPPER(table_name)
),
sys_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(privilege) AS privilege,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_sys_privs
     GROUP BY UPPER(grantee), UPPER(privilege)
),
role_now AS (
    SELECT UPPER(grantee) AS grantee,
           UPPER(granted_role) AS granted_role,
           MAX(CASE WHEN UPPER(NVL(admin_option, 'NO')) = 'YES' THEN 1 ELSE 0 END) AS has_admin
      FROM dba_role_privs
     GROUP BY UPPER(grantee), UPPER(granted_role)
),
diag AS (
    SELECT p.grantee,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_wgo = 0 THEN 'MISMATCH_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN obj_now n
        ON p.grant_type = 'OBJECT'
       AND n.grantee = UPPER(p.grantee)
       AND n.privilege = UPPER(p.privilege)
       AND n.owner = UPPER(NVL(p.target_schema, ''))
       AND n.table_name = UPPER(NVL(p.target_name, ''))
    UNION ALL
    SELECT p.grantee,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_admin = 0 THEN 'MISMATCH_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN sys_now n
        ON p.grant_type = 'SYSTEM'
       AND n.grantee = UPPER(p.grantee)
       AND n.privilege = UPPER(p.privilege)
    UNION ALL
    SELECT p.grantee,
           CASE
             WHEN n.grantee IS NULL THEN 'MISSING'
             WHEN p.with_grant_option = 1 AND n.has_admin = 0 THEN 'MISMATCH_OPTION'
             ELSE 'ALREADY_OK'
           END AS diagnose
      FROM planned p
      LEFT JOIN role_now n
        ON p.grant_type = 'ROLE'
       AND n.grantee = UPPER(p.grantee)
       AND n.granted_role = UPPER(p.privilege)
),
all_diag AS (
    SELECT grantee, diagnose FROM diag
    UNION ALL
    SELECT grantee, 'UNSUPPORTED_FILTERED' AS diagnose FROM filtered
)
SELECT grantee,
       SUM(CASE WHEN diagnose = 'MISSING' THEN 1 ELSE 0 END) AS missing_cnt,
       SUM(CASE WHEN diagnose = 'MISMATCH_OPTION' THEN 1 ELSE 0 END) AS mismatch_option_cnt,
       SUM(CASE WHEN diagnose = 'UNSUPPORTED_FILTERED' THEN 1 ELSE 0 END) AS unsupported_cnt
  FROM all_diag
 GROUP BY grantee
 ORDER BY missing_cnt DESC, mismatch_option_cnt DESC, unsupported_cnt DESC, grantee;

-- SQL-65 动作汇总（可执行工作面）
SELECT action_type, object_type, COUNT(*) AS cnt
  FROM DIFF_REPORT_ACTIONS_V
 WHERE report_id = :report_id
 GROUP BY action_type, object_type
 ORDER BY action_type, cnt DESC, object_type;

-- SQL-66 未闭环动作（pending）
SELECT action_type, object_type, schema_name, object_name,
       reason, resolution_status, resolved_by, resolved_at, note
  FROM DIFF_REPORT_PENDING_ACTIONS_V
 WHERE report_id = :report_id
 ORDER BY action_type, object_type, schema_name, object_name;

-- SQL-67 可用性异常（重点：VIEW/SYNONYM）
SELECT object_type, schema_name, object_name,
       status, usable, reason,
       reason_class
  FROM DIFF_REPORT_USABILITY_CLASS_V
 WHERE report_id = :report_id
   AND (status <> 'OK' OR NVL(usable, 0) = 0)
 ORDER BY object_type, schema_name, object_name;

-- SQL-67A VIEW 因 DBLINK 被判不支持（reason_code=VIEW_DBLINK）
SELECT d.source_schema, d.source_name, d.status, d.reason
  FROM DIFF_REPORT_DETAIL d
 WHERE d.report_id = :report_id
   AND d.report_type = 'UNSUPPORTED'
   AND d.object_type = 'VIEW'
   AND EXISTS (
       SELECT 1
         FROM DIFF_REPORT_DETAIL_ITEM i
        WHERE i.report_id = d.report_id
          AND i.report_type = d.report_type
          AND i.object_type = d.object_type
          AND i.source_schema = d.source_schema
          AND i.source_name = d.source_name
          AND i.item_type = 'REASON_CODE'
          AND DBMS_LOB.SUBSTR(i.item_value, 4000, 1) = 'VIEW_DBLINK'
   )
 ORDER BY d.source_schema, d.source_name;

-- SQL-67B VIEW_DBLINK 根因与建议（REASON_CODE/ROOT_CAUSE/ACTION/DETAIL）
SELECT source_schema, source_name,
       MAX(CASE WHEN item_type='REASON_CODE' THEN DBMS_LOB.SUBSTR(item_value, 4000, 1) END) AS reason_code,
       MAX(CASE WHEN item_type='ROOT_CAUSE'  THEN DBMS_LOB.SUBSTR(item_value, 4000, 1) END) AS root_cause,
       MAX(CASE WHEN item_type='ACTION'      THEN DBMS_LOB.SUBSTR(item_value, 4000, 1) END) AS action,
       MAX(CASE WHEN item_type='DETAIL'      THEN DBMS_LOB.SUBSTR(item_value, 4000, 1) END) AS detail
  FROM DIFF_REPORT_DETAIL_ITEM
 WHERE report_id = :report_id
   AND report_type = 'UNSUPPORTED'
   AND object_type = 'VIEW'
 GROUP BY source_schema, source_name
HAVING MAX(CASE WHEN item_type='REASON_CODE' THEN DBMS_LOB.SUBSTR(item_value, 4000, 1) END) = 'VIEW_DBLINK'
 ORDER BY source_schema, source_name;

-- SQL-68 PACKAGE / PACKAGE BODY 对比异常
SELECT schema_name, object_name, object_type,
       src_status, tgt_status, diff_status,
       diff_hash, diff_summary, diff_path
  FROM DIFF_REPORT_PACKAGE_COMPARE
 WHERE report_id = :report_id
   AND NVL(diff_status, 'UNKNOWN') <> 'MATCH'
 ORDER BY schema_name, object_name, object_type;

-- SQL-69 触发器状态差异
SELECT schema_name, trigger_name,
       src_event, tgt_event,
       src_enabled, tgt_enabled,
       src_valid, tgt_valid,
       diff_status, reason
  FROM DIFF_REPORT_TRIGGER_STATUS
 WHERE report_id = :report_id
 ORDER BY schema_name, trigger_name;

-- SQL-70 report_to_db 写库异常（该 report_id）
SELECT error_id, table_name, created_at,
       DBMS_LOB.SUBSTR(error_message, 500, 1) AS error_message,
       DBMS_LOB.SUBSTR(sql_snippet, 500, 1) AS sql_snippet
  FROM DIFF_REPORT_WRITE_ERRORS
 WHERE report_id = :report_id
 ORDER BY created_at DESC;

-- SQL-71 逐行查看某个 txt 报告（完全替代本地 cat）
SELECT line_no, line_text
  FROM DIFF_REPORT_ARTIFACT_LINE
 WHERE report_id = :report_id
   AND file_path = :file_path
 ORDER BY line_no;

-- SQL-72 按 artifact_type 统计逐行入库规模（验证 100% 覆盖）
SELECT artifact_type, COUNT(*) AS line_cnt
  FROM DIFF_REPORT_ARTIFACT_LINE
 WHERE report_id = :report_id
 GROUP BY artifact_type
 ORDER BY line_cnt DESC, artifact_type;

-- SQL-73 工件目录 vs 逐行表一致性校验（按文件）
SELECT a.artifact_type,
       a.file_path,
       a.status,
       a.row_count AS logical_rows,
       NVL(l.line_cnt, 0) AS stored_lines
  FROM DIFF_REPORT_ARTIFACT a
  LEFT JOIN (
      SELECT report_id, file_path, COUNT(*) AS line_cnt
        FROM DIFF_REPORT_ARTIFACT_LINE
       WHERE report_id = :report_id
       GROUP BY report_id, file_path
  ) l
    ON l.report_id = a.report_id
   AND l.file_path = a.file_path
 WHERE a.report_id = :report_id
 ORDER BY a.artifact_type, a.file_path;

------------------------------------------------------------
G. 多余对象 / 同义词专项（SQL-74 ~ SQL-77）
------------------------------------------------------------

-- SQL-74 主对象“多余清单”总览（来自 extra_targets_detail_* 入库行）
WITH f AS (
    SELECT file_path
      FROM DIFF_REPORT_ARTIFACT
     WHERE report_id = :report_id
       AND file_path LIKE '%/extra_targets_detail_%'
     ORDER BY file_path DESC
     FETCH FIRST 1 ROW ONLY
)
SELECT REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 1) AS object_type,
       REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 2) AS target_full,
       al.line_no
  FROM DIFF_REPORT_ARTIFACT_LINE al
  JOIN f ON al.file_path = f.file_path
 WHERE al.report_id = :report_id
   AND al.line_text IS NOT NULL
   AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) NOT LIKE '#%'
   AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) <> 'TYPE|TARGET_FULL'
 ORDER BY object_type, target_full;

-- SQL-75 仅看“多余同义词”列表（兼容 Oracle PUBLIC / OB __public）
WITH f AS (
    SELECT file_path
      FROM DIFF_REPORT_ARTIFACT
     WHERE report_id = :report_id
       AND file_path LIKE '%/extra_targets_detail_%'
     ORDER BY file_path DESC
     FETCH FIRST 1 ROW ONLY
),
x AS (
    SELECT REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 1) AS object_type,
           REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 2) AS target_full
      FROM DIFF_REPORT_ARTIFACT_LINE al
      JOIN f ON al.file_path = f.file_path
     WHERE al.report_id = :report_id
       AND al.line_text IS NOT NULL
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) NOT LIKE '#%'
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) <> 'TYPE|TARGET_FULL'
)
SELECT target_full
  FROM x
 WHERE UPPER(object_type) = 'SYNONYM'
 ORDER BY target_full;

-- SQL-76 多余同义词按 schema 统计（可快速定位 __public / 业务 schema）
WITH f AS (
    SELECT file_path
      FROM DIFF_REPORT_ARTIFACT
     WHERE report_id = :report_id
       AND file_path LIKE '%/extra_targets_detail_%'
     ORDER BY file_path DESC
     FETCH FIRST 1 ROW ONLY
),
x AS (
    SELECT REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 1) AS object_type,
           REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 2) AS target_full
      FROM DIFF_REPORT_ARTIFACT_LINE al
      JOIN f ON al.file_path = f.file_path
     WHERE al.report_id = :report_id
       AND al.line_text IS NOT NULL
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) NOT LIKE '#%'
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) <> 'TYPE|TARGET_FULL'
),
s AS (
    SELECT target_full,
           CASE
             WHEN INSTR(target_full, '.') > 0 THEN SUBSTR(target_full, 1, INSTR(target_full, '.') - 1)
             ELSE '(NO_SCHEMA)'
           END AS target_schema
      FROM x
     WHERE UPPER(object_type) = 'SYNONYM'
)
SELECT target_schema, COUNT(*) AS extra_synonym_cnt
  FROM s
 GROUP BY target_schema
 ORDER BY extra_synonym_cnt DESC, target_schema;

-- SQL-77 多余同义词“是否在映射期望内”复核（正常应多数为 NOT_IN_MAPPING）
WITH f AS (
    SELECT file_path
      FROM DIFF_REPORT_ARTIFACT
     WHERE report_id = :report_id
       AND file_path LIKE '%/extra_targets_detail_%'
     ORDER BY file_path DESC
     FETCH FIRST 1 ROW ONLY
),
x AS (
    SELECT REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 2) AS target_full
      FROM DIFF_REPORT_ARTIFACT_LINE al
      JOIN f ON al.file_path = f.file_path
     WHERE al.report_id = :report_id
       AND al.line_text IS NOT NULL
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) NOT LIKE '#%'
       AND DBMS_LOB.SUBSTR(al.line_text, 4000, 1) <> 'TYPE|TARGET_FULL'
       AND UPPER(REGEXP_SUBSTR(DBMS_LOB.SUBSTR(al.line_text, 4000, 1), '[^|]+', 1, 1)) = 'SYNONYM'
),
m AS (
    SELECT UPPER(tgt_schema || '.' || tgt_name) AS target_full
      FROM DIFF_REPORT_OBJECT_MAPPING
     WHERE report_id = :report_id
       AND object_type = 'SYNONYM'
)
SELECT x.target_full,
       CASE WHEN m.target_full IS NULL THEN 'NOT_IN_MAPPING' ELSE 'IN_MAPPING' END AS mapping_flag
  FROM x
  LEFT JOIN m ON UPPER(x.target_full) = m.target_full
 ORDER BY mapping_flag DESC, x.target_full;

============================================================
建议排查顺序（实战）
1) SQL-01/02/08/10 先建立全局认知。
2) SQL-25/26/27 + SQL-28~31 先消化“不支持/阻断”（改造项）。
3) SQL-15/16/21/22 再看“可修复缺失”。
4) SQL-36~46 处理结构不一致。
5) SQL-47~59 定位依赖链、remap、同义词/public 特殊问题。
6) SQL-60~73 收口权限、可用性、package/trigger 与写库异常。
7) SQL-74~77 专项核查“多余对象/多余同义词”。
============================================================
