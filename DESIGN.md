# 数据库对象对比工具 (`db_comparator_fixup_codex.py`) 设计文档

本文档旨在阐述 `db_comparator_fixup_codex.py` 脚本的设计思路、核心架构和工作流程。

## 1. 核心目标

本工具的核心目标是自动化地对比 Oracle (源端) 和 OceanBase (目标端) 数据库之间的模式(Schema)对象，找出两者之间的差异，并自动生成可执行的 SQL “修补”脚本，以帮助用户快速地将目标端数据库的结构与源端对齐。

它主要解决以下问题：
- **对象缺失**：目标端缺少源端存在的表、视图、索引等。
- **对象不一致**：
    - 表的列集合不匹配（多列、少列）。
    - 表的列定义不匹配（如 `VARCHAR` 长度）。
    - 索引、约束的结构不匹配。
- **手动对比效率低下且易出错**：对于拥有成百上千个对象的复杂数据库，手动排查几乎是不可能的。

## 2. 核心设计思想：一次转储，本地对比

为了最大限度地提升性能并减少对目标数据库的压力，本工具采用了 **“一次转储，本地对比” (Dump-Once, Compare-Locally)** 的核心架构。

传统做法可能是在循环中反复查询源端和目标端，每次查询一个对象。这种方式会导致成千上万次数据库网络请求，性能极差。

本工具的工作流程如下：
1.  **连接源端 Oracle**：获取所有待校验对象的完整列表。
2.  **一次性转储目标端元数据**：通过 `obclient` 命令行工具，执行少量预设的 SQL 查询，将目标端 OceanBase 中所有相关的元数据（如 `ALL_OBJECTS`, `ALL_TAB_COLUMNS`, `ALL_INDEXES` 等）一次性地 dump 到本地。
3.  **本地内存对比**：将 dump 下来的目标端元数据加载到 Python 的内存数据结构中。后续所有的对比逻辑——包括对象存在性、列名匹配、索引/约束结构对比等——完全在本地内存中完成，无需再与目标端数据库进行任何交互。

这种设计的优势显而易见：
- **高性能**：将成千上万次远程查询优化为几次批量数据拉取，极大提升了校验速度。
- **低负载**：显著降低了对目标端 OceanBase 数据库的查询压力。
- **逻辑清晰**：将数据获取和数据分析两个阶段解耦，代码结构更清晰。

## 3. 配置文件驱动

为了实现灵活性和可复用性，工具的行为完全由外部配置文件驱动。

-   **`db.ini`**: 主配置文件。
    -   `[ORACLE_SOURCE]`: 定义源端 Oracle 的连接信息（用户、密码、DSN）。
    -   `[OCEANBASE_TARGET]`: 定义目标端 OceanBase 的连接信息（Host、Port、用户、密码、`obclient` 可执行文件路径）。
    -   `[SETTINGS]`: 定义核心校验参数，如：
        -   `source_schemas`: 需要扫描的源端 schema 列表（支持多个）。
        -   `remap_file`: 重映射规则文件的路径。
        -   `obclient_timeout`: `obclient` 执行的超时时间，增强程序健壮性。

-   **`remap_rules.txt`**: 对象重映射规则文件。
    -   解决了在不同环境或迁移项目中，对象命名可能不一致的问题。
    -   例如，源端的 `PROD.ORDERS` 在目标端可能对应 `MIG_PROD.ORDERS`。只需在文件中定义 `PROD.ORDERS=MIG_PROD.ORDERS` 即可。
    -   工具会自动根据此规则生成“最终校验清单”。

## 4. 详细工作流程

程序严格按照以下步骤执行：

1.  **加载配置**：读取 `db.ini` 和 `remap_rules.txt`。
2.  **获取源对象**：连接 Oracle，查询 `ALL_OBJECTS` 视图，获取 `source_schemas` 下所有需要对比的主对象（表、视图、程序、函数、包等）列表。
3.  **验证规则**：检查 `remap_rules.txt` 中定义的源对象是否真实存在于 Oracle 中，并对无效规则提出警告。
4.  **生成主校验清单**：应用 `remap_rules`，生成一个从“源对象”到“目标对象”的完整映射清单。在此过程中，会检测并阻止“多对一”的非法映射（即多个源对象映射到同一个目标对象）。
5.  **转储 OceanBase 元数据**：根据主校验清单计算出所有需要查询的目标端 schema，然后调用 `obclient` 执行一系列 `SELECT` 语句，将元数据 dump 下来并解析到内存中的 `ObMetadata` 对象中。
6.  **转储 Oracle 元数据**：为避免在后续的修补脚本生成阶段反复查询 Oracle，此步骤会预先批量加载所有需要用到的 Oracle 元数据（如列定义、索引、约束等）到内存中的 `OracleMetadata` 对象。
7.  **执行对比**：
    -   **主对象对比**：遍历主校验清单，检查目标端对象是否存在。对于表，额外对比列名集合。
    -   **扩展对象对比**：对于校验通过的表，进一步对比其关联的索引、约束和触发器。同时，按 schema 对比序列。
8.  **生成修补脚本**：
    -   根据对比结果中的“缺失”和“不匹配”项，调用 Oracle 的 `DBMS_METADATA.GET_DDL` 包获取源对象的标准 DDL。
    -   对获取的 DDL 进行规范化和重映射处理（例如，将源 schema 名替换为目标 schema 名）。
    -   对于表的列差异，则直接生成 `ALTER TABLE ... ADD/MODIFY/DROP` 语句。
    -   所有生成的 `.sql` 脚本被分类存放在 `fix_up/` 目录下，等待用户审核。
9.  **输出报告**：使用 `rich` 库在控制台打印一份格式化、带颜色高亮的详细报告，清晰地展示一致、缺失、不匹配的对象列表，并提供修补脚本的路径指引。

## 5. 对象对比逻辑

-   **TABLE**:
    -   存在性检查。
    -   列名集合对比（忽略以 `OMS_` 开头的内部列）。
    -   `VARCHAR`/`VARCHAR2` 类型列的长度检查（默认目标端应为源端长度的 1.5 倍）。
-   **VIEW, PROCEDURE, FUNCTION, PACKAGE, SYNONYM**:
    -   只检查目标端是否存在。
-   **INDEX**:
    -   存在性检查。
    -   结构对比：索引的列集合、列顺序、唯一性 (`UNIQUE` / `NONUNIQUE`)。
-   **CONSTRAINT (PK/UK/FK)**:
    -   存在性检查。
    -   结构对比：约束类型 (`P`/`U`/`R`) 和约束的列集合。
-   **SEQUENCE, TRIGGER**:
    -   只检查目标端是否存在。

## 6. 健壮性设计

-   **超时机制**：所有 `obclient` 的调用都设置了超时时间，防止因网络或数据库问题导致程序无限期挂起。
-   **配置验证**：在程序早期阶段对 `db.ini` 和 `remap_rules.txt` 进行严格校验，尽早发现配置错误。
-   **清晰的错误提示**：在发生数据库连接失败、文件未找到、配置错误等问题时，提供明确的错误信息并安全退出。
-   **依赖检查**：程序启动时会检查 `oracledb` 和 `rich` 等关键 Python 库是否存在，引导用户完成安装。
