以下方案展示了如何在 Oracle 与 OceanBase 中构造一个“高负载 + 复杂 Remap”的交叉映射案例，并在每一步提供需要执行的 DDL。步骤越做越大即可扩展压力。为保持可读性，建议先复制核心示例，再批量生成更多对象。

======================================================================
1. 环境准备
======================================================================
1.1 创建 Oracle Schema 及授权
------------------------------------------------------------------
CREATE USER ORA_APP IDENTIFIED BY ora_app_pass DEFAULT TABLESPACE USERS;
CREATE USER ORA_HR  IDENTIFIED BY ora_hr_pass  DEFAULT TABLESPACE USERS;
CREATE USER ORA_ERP IDENTIFIED BY ora_erp_pass DEFAULT TABLESPACE USERS;
GRANT CONNECT, RESOURCE TO ORA_APP;
GRANT CONNECT, RESOURCE TO ORA_HR;
GRANT CONNECT, RESOURCE TO ORA_ERP;

1.2 创建 OceanBase Schema/用户
------------------------------------------------------------------
CREATE USER OB_DATA IDENTIFIED BY ob_data_pass;
CREATE USER OB_ANALYTICS IDENTIFIED BY ob_ana_pass;
CREATE USER OB_STAGE IDENTIFIED BY ob_stage_pass;
CREATE USER OB_SHARE IDENTIFIED BY ob_share_pass;
GRANT ALL PRIVILEGES ON *.* TO OB_DATA;
GRANT ALL PRIVILEGES ON *.* TO OB_ANALYTICS;
GRANT ALL PRIVILEGES ON *.* TO OB_STAGE;
GRANT ALL PRIVILEGES ON *.* TO OB_SHARE;

======================================================================
2. Oracle 端构造对象（示例，可复制扩展）
======================================================================
2.1 ORA_APP：表/索引/约束/序列
------------------------------------------------------------------
CREATE TABLE ORA_APP.CUSTOMERS (
    CUST_ID      NUMBER(10)    CONSTRAINT PK_CUSTOMERS PRIMARY KEY,
    CUST_NAME    VARCHAR2(60)  NOT NULL,
    CUST_EMAIL   VARCHAR2(90),
    STATUS       VARCHAR2(2)   DEFAULT 'A',
    CREATED_AT   DATE          DEFAULT SYSDATE
);
CREATE TABLE ORA_APP.ORDERS (
    ORDER_ID     NUMBER(12),
    CUST_ID      NUMBER(10) NOT NULL,
    ORDER_TOTAL  NUMBER(12,2),
    REMARK       VARCHAR2(255),
    CREATED_AT   DATE DEFAULT SYSDATE,
    CONSTRAINT PK_ORDERS PRIMARY KEY (ORDER_ID),
    CONSTRAINT FK_ORDERS_CUSTOMERS FOREIGN KEY (CUST_ID)
        REFERENCES ORA_APP.CUSTOMERS (CUST_ID),
    CONSTRAINT UK_ORDERS_UNIQ UNIQUE (CUST_ID, CREATED_AT)
);
CREATE INDEX IDX_ORDERS_CUST  ON ORA_APP.ORDERS (CUST_ID);
CREATE INDEX IDX_ORDERS_TOTAL ON ORA_APP.ORDERS (ORDER_TOTAL);
CREATE SEQUENCE ORA_APP.SEQ_CUSTOMERS START WITH 1000;
CREATE SEQUENCE ORA_APP.SEQ_ORDERS    START WITH 10000;

2.2 ORA_HR：表/约束/索引/序列
------------------------------------------------------------------
CREATE TABLE ORA_HR.JOBS (
    JOB_ID    VARCHAR2(20),
    JOB_NAME  VARCHAR2(100),
    MIN_SAL   NUMBER(8,2),
    MAX_SAL   NUMBER(8,2),
    CONSTRAINT PK_JOBS PRIMARY KEY (JOB_ID)
);
CREATE TABLE ORA_HR.DEPARTMENTS (
    DEPT_ID    NUMBER(6),
    DEPT_NAME  VARCHAR2(90),
    MGR_ID     NUMBER(6),
    CONSTRAINT PK_DEPT PRIMARY KEY (DEPT_ID)
);
CREATE TABLE ORA_HR.EMPLOYEES (
    EMP_ID     NUMBER(9),
    DEPT_ID    NUMBER(6),
    JOB_ID     VARCHAR2(20),
    EMP_NAME   VARCHAR2(80),
    EMAIL      VARCHAR2(60),
    SALARY     NUMBER(9,2),
    CONSTRAINT PK_EMP PRIMARY KEY (EMP_ID),
    CONSTRAINT FK_EMP_DEPT FOREIGN KEY (DEPT_ID) REFERENCES ORA_HR.DEPARTMENTS(DEPT_ID),
    CONSTRAINT FK_EMP_JOB  FOREIGN KEY (JOB_ID) REFERENCES ORA_HR.JOBS(JOB_ID)
);
CREATE INDEX  IDX_EMP_DEPT ON ORA_HR.EMPLOYEES (DEPT_ID);
CREATE UNIQUE INDEX UK_EMP_EMAIL ON ORA_HR.EMPLOYEES (EMAIL);
CREATE SEQUENCE ORA_HR.SEQ_EMP START WITH 1;
CREATE SEQUENCE ORA_HR.SEQ_JOB START WITH 100;

2.3 触发器
------------------------------------------------------------------
CREATE OR REPLACE TRIGGER ORA_APP.TRG_ORDERS_BI
BEFORE INSERT ON ORA_APP.ORDERS
FOR EACH ROW
BEGIN
    IF :NEW.ORDER_ID IS NULL THEN
        SELECT SEQ_ORDERS.NEXTVAL INTO :NEW.ORDER_ID FROM DUAL;
    END IF;
END;
/
CREATE OR REPLACE TRIGGER ORA_HR.TRG_EMP_BI
BEFORE INSERT ON ORA_HR.EMPLOYEES
FOR EACH ROW
BEGIN
    IF :NEW.EMP_ID IS NULL THEN
        SELECT SEQ_EMP.NEXTVAL INTO :NEW.EMP_ID FROM DUAL;
    END IF;
END;
/

2.4 存储过程、函数、包、包体
------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE ORA_APP.SP_ADD_CUSTOMER(
    p_name IN VARCHAR2, p_email IN VARCHAR2
) AS
BEGIN
    INSERT INTO ORA_APP.CUSTOMERS(CUST_ID, CUST_NAME, CUST_EMAIL)
    VALUES (SEQ_CUSTOMERS.NEXTVAL, p_name, p_email);
END;
/
CREATE OR REPLACE FUNCTION ORA_APP.FN_ORDER_TOTAL(p_cust_id NUMBER)
RETURN NUMBER AS
    v_total NUMBER;
BEGIN
    SELECT NVL(SUM(ORDER_TOTAL),0) INTO v_total
      FROM ORA_APP.ORDERS
     WHERE CUST_ID = p_cust_id;
    RETURN v_total;
END;
/
CREATE OR REPLACE PACKAGE ORA_HR.PKG_EMP_MANAGE AS
    PROCEDURE RAISE_SALARY(p_emp_id NUMBER, p_rate NUMBER);
    FUNCTION GET_DEPT_HEADCOUNT(p_dept_id NUMBER) RETURN NUMBER;
END PKG_EMP_MANAGE;
/
CREATE OR REPLACE PACKAGE BODY ORA_HR.PKG_EMP_MANAGE AS
    PROCEDURE RAISE_SALARY(p_emp_id NUMBER, p_rate NUMBER) IS
    BEGIN
        UPDATE ORA_HR.EMPLOYEES
           SET SALARY = SALARY * (1 + p_rate)
         WHERE EMP_ID = p_emp_id;
    END;
    FUNCTION GET_DEPT_HEADCOUNT(p_dept_id NUMBER) RETURN NUMBER IS
        v_cnt NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_cnt FROM ORA_HR.EMPLOYEES WHERE DEPT_ID = p_dept_id;
        RETURN v_cnt;
    END;
END PKG_EMP_MANAGE;
/

2.5 视图、同义词
------------------------------------------------------------------
CREATE VIEW ORA_APP.VW_ACTIVE_CUSTOMERS AS
SELECT CUST_ID, CUST_NAME, STATUS
  FROM ORA_APP.CUSTOMERS
 WHERE STATUS = 'A';
CREATE SYNONYM ORA_APP.SYN_EMP FOR ORA_HR.EMPLOYEES;

======================================================================
3. OceanBase 端故意制造差异
======================================================================
- Remap 到 OB schema 的对象只部分创建。
- VARCHAR2 列不按 1.5 倍扩展。
- 少建索引/约束/触发器/序列。
- 部分对象完全不创建，以制造缺失。

示例：
CREATE TABLE OB_DATA.CUST (
    CUST_ID      NUMBER(10) PRIMARY KEY,
    CUST_NAME    VARCHAR(60),      -- 故意不乘 1.5
    CUST_EMAIL   VARCHAR(90),
    CREATED_AT   DATE
);
-- 序列故意缺失：不创建 OB_DATA.SEQ_CUSTOMERS
CREATE TABLE OB_ANALYTICS.ORDERS_FACT (
    ORDER_ID     NUMBER(12),
    CUST_ID      NUMBER(10),
    ORDER_TOTAL  NUMBER(12,2),
    CREATED_AT   DATE
);
-- 其他 remap 目标只建部分列或不建索引/约束/触发器

======================================================================
4. Remap 规则示例（remap_rules.txt）
======================================================================
ORA_APP.CUSTOMERS          = OB_DATA.CUST
ORA_APP.ORDERS             = OB_ANALYTICS.ORDERS_FACT
ORA_APP.SEQ_CUSTOMERS      = OB_DATA.SEQ_CUSTOMERS
ORA_APP.SEQ_ORDERS         = OB_ANALYTICS.SEQ_ORDERS
ORA_APP.SP_ADD_CUSTOMER    = OB_DATA.SP_ADD_CUST
ORA_APP.FN_ORDER_TOTAL     = OB_ANALYTICS.FN_ORDER_TOTAL
ORA_APP.VW_ACTIVE_CUSTOMERS= OB_DATA.VW_ACTIVE_CUST
ORA_HR.EMPLOYEES           = OB_STAGE.EMP
ORA_HR.DEPARTMENTS         = OB_STAGE.DEPT
ORA_HR.JOBS                = OB_STAGE.JOBS
ORA_HR.PKG_EMP_MANAGE      = OB_SHARE.PKG_EMP
ORA_HR.PKG_EMP_MANAGE BODY = OB_SHARE.PKG_EMP BODY
ORA_HR.TRG_EMP_BI          = OB_STAGE.TRG_EMP_BI
# 其余对象默认 1:1，使 remap 呈现“蜘蛛网”式交叉映射。

======================================================================
5. 检查要求
======================================================================
1) 在 Oracle 端插入足够数据，放大 Dump 负载。
2) 在 OB 端仅部分建对象，并保持 VARCHAR2 长度未乘 1.5。
3) 运行 db_comparator_fixup_release.py：
   - 表列差异会提示缺列/多列/VARCHAR 长度不足。
   - 索引/约束/序列/触发器缺失会分别列出。
   - 新增的 PACKAGE BODY 与 Remap 逻辑会同时校验。
4) Fix_up 目录下生成的脚本包含 CREATE / ALTER / 代码对象 DDL，需人工复核。

======================================================================
6. 扩展建议
======================================================================
- 复制以上 DDL 模板，批量生成更多 schema（ORA_FIN、ORA_SCM 等）和更多对象。
- 为不同源 schema 设置多个目标 schema，使映射呈现多对多。
- 在 Remap 文件中加入刻意冲突的映射（同一目标被多次映射）以验证工具对配置错误的检测。
- 在 OB 端创建额外的“噪声对象”（多余序列/触发器），让工具在报告中列出“多余对象”。
- 使用脚本自动化创建/删除对象，模拟真实迁移环境的动态变化。

只要按照此方案逐步执行，并不断扩充对象数量，就可以获得一个覆盖“表/索引/约束/序列/触发器/同义词/视图/存储过程/函数/包/包体”等全部对象、Remap 关系呈蜘蛛网交叉、多种异常并存的压力案例。
