-- Labyrinth Case - Oracle 源端初始化脚本
-- 作用：清理并重建 LAB_* 源 schema，覆盖复杂 remap、跨 schema 依赖、各类对象。
-- [V2 - 修复版：调整对象创建顺序，分离约束和授权，确保一次性成功]

-- 1) 清理旧用户
BEGIN
  FOR u IN (
    SELECT username FROM all_users
     WHERE username IN ('LAB_CORE','LAB_FIN','LAB_APP','LAB_UTIL')
  ) LOOP
    EXECUTE IMMEDIATE 'DROP USER '||u.username||' CASCADE';
  END LOOP;
END;
/

-- 2) 创建用户并授予通用权限
CREATE USER LAB_CORE IDENTIFIED BY lab_core;
CREATE USER LAB_FIN  IDENTIFIED BY lab_fin;
CREATE USER LAB_APP  IDENTIFIED BY lab_app;
CREATE USER LAB_UTIL IDENTIFIED BY lab_util;

GRANT CONNECT, RESOURCE TO LAB_CORE, LAB_FIN, LAB_APP, LAB_UTIL;
GRANT CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM TO LAB_CORE, LAB_FIN, LAB_APP, LAB_UTIL;
GRANT SELECT ON LAB_CORE.CORE_ACCOUNT to LAB_CORE;
GRANT CREATE MATERIALIZED VIEW TO LAB_CORE; -- 为 MV_STATUS_COUNT 显式授权，确保可创建物化视图
GRANT CREATE TABLE, CREATE SEQUENCE, CREATE TRIGGER, CREATE PROCEDURE, CREATE TYPE TO LAB_CORE, LAB_FIN, LAB_APP, LAB_UTIL;
GRANT UNLIMITED TABLESPACE TO LAB_CORE, LAB_FIN, LAB_APP, LAB_UTIL;

--------------------------------------------------------------------------------
-- 3) 阶段一：创建所有表和序列 (不含外键)
--------------------------------------------------------------------------------
PROMPT --- Creating Tables and Sequences ---;
ALTER SESSION SET CURRENT_SCHEMA = LAB_CORE;
CREATE SEQUENCE SEQ_ACCOUNT START WITH 1000 INCREMENT BY 1;
CREATE TABLE CORE_ACCOUNT (
  ACCOUNT_ID   NUMBER PRIMARY KEY,
  NAME         VARCHAR2(60) NOT NULL,
  STATUS       VARCHAR2(20) NOT NULL,
  REGION_CODE  VARCHAR2(8),
  CREATED_AT   DATE DEFAULT SYSDATE,
  NOTE         VARCHAR2(200)
);

ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
CREATE SEQUENCE SEQ_LEDGER START WITH 5000 INCREMENT BY 10;
CREATE TABLE FIN_LEDGER (
  LEDGER_ID   NUMBER PRIMARY KEY,
  ACCOUNT_ID  NUMBER NOT NULL,
  AMOUNT      NUMBER(12,2) NOT NULL,
  CURRENCY    VARCHAR2(3) DEFAULT 'CNY',
  REMARK      VARCHAR2(100)
);

ALTER SESSION SET CURRENT_SCHEMA = LAB_APP;
CREATE SEQUENCE SEQ_ORDER START WITH 20000 INCREMENT BY 1;
CREATE SEQUENCE SEQ_ORDER_LINE START WITH 90000 INCREMENT BY 1;
CREATE TABLE APP_ORDER (
  ORDER_ID    NUMBER PRIMARY KEY,
  ACCOUNT_ID  NUMBER NOT NULL,
  ORDER_CODE  VARCHAR2(30) NOT NULL,
  CHANNEL     VARCHAR2(20),
  NOTE        VARCHAR2(400),
  CREATED_AT  DATE DEFAULT SYSDATE,
  CREATED_BY  VARCHAR2(30)
);
CREATE TABLE APP_ORDER_LINE (
  ORDER_LINE_ID NUMBER PRIMARY KEY,
  ORDER_ID      NUMBER NOT NULL,
  SKU           VARCHAR2(40),
  QTY           NUMBER(10,2),
  UNIT_PRICE    NUMBER(10,2)
);

ALTER SESSION SET CURRENT_SCHEMA = LAB_UTIL;
CREATE SEQUENCE SEQ_LOG START WITH 1;
CREATE TABLE UTIL_LOG (
  LOG_ID     NUMBER PRIMARY KEY,
  TAG        VARCHAR2(30),
  DETAILS    VARCHAR2(200),
  CREATED_AT DATE DEFAULT SYSDATE
);

--------------------------------------------------------------------------------
-- 4) 阶段二：授予表引用权限并创建外键
--------------------------------------------------------------------------------
PROMPT --- Granting table permissions and creating Foreign Keys ---;
ALTER SESSION SET CURRENT_SCHEMA = LAB_CORE;
GRANT REFERENCES ON CORE_ACCOUNT TO LAB_FIN;
GRANT REFERENCES ON CORE_ACCOUNT TO LAB_APP;
GRANT SELECT ON CORE_ACCOUNT TO LAB_APP; -- For V_ORDER_SUM view

ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
ALTER TABLE FIN_LEDGER ADD CONSTRAINT FK_LEDGER_ACCT FOREIGN KEY (ACCOUNT_ID) REFERENCES LAB_CORE.CORE_ACCOUNT(ACCOUNT_ID);

ALTER SESSION SET CURRENT_SCHEMA = LAB_APP;
ALTER TABLE APP_ORDER ADD CONSTRAINT FK_ORDER_ACCT FOREIGN KEY (ACCOUNT_ID) REFERENCES LAB_CORE.CORE_ACCOUNT(ACCOUNT_ID);
ALTER TABLE APP_ORDER_LINE ADD CONSTRAINT FK_LINE_ORDER FOREIGN KEY (ORDER_ID) REFERENCES APP_ORDER(ORDER_ID);

--------------------------------------------------------------------------------
-- 5) 阶段三：创建 Types, Views, Functions, Package Specs
--------------------------------------------------------------------------------
PROMPT --- Creating Types, Views, Functions, Package Specs ---;
-- LAB_CORE
ALTER SESSION SET CURRENT_SCHEMA = LAB_CORE;
CREATE OR REPLACE TYPE T_AUDIT_TAG AS OBJECT (
  TAG VARCHAR2(30),
  MEMBER FUNCTION TO_LABEL RETURN VARCHAR2
);
/
CREATE OR REPLACE TYPE BODY T_AUDIT_TAG AS
  MEMBER FUNCTION TO_LABEL RETURN VARCHAR2 IS
  BEGIN
    RETURN '[' || UPPER(SELF.TAG) || ']';
  END;
END;
/
CREATE OR REPLACE VIEW V_ACCOUNT_ACTIVE AS
SELECT ACCOUNT_ID, NAME, STATUS, REGION_CODE
  FROM CORE_ACCOUNT
 WHERE STATUS = 'ACTIVE';

-- Grant explicit select for MV, which is good practice.
GRANT SELECT ON CORE_ACCOUNT TO LAB_CORE;
CREATE MATERIALIZED VIEW MV_STATUS_COUNT
BUILD IMMEDIATE REFRESH COMPLETE ON DEMAND
AS
SELECT STATUS, COUNT(*) AS CNT
  FROM CORE_ACCOUNT
 GROUP BY STATUS;

CREATE OR REPLACE PACKAGE PKG_CORE_UTIL AS
  FUNCTION ACCOUNT_LABEL(P_ACCOUNT_ID NUMBER) RETURN VARCHAR2;
  PROCEDURE REFRESH_STATUS(P_ACCOUNT_ID NUMBER);
END PKG_CORE_UTIL;
/

-- LAB_FIN
ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
CREATE OR REPLACE FUNCTION FN_GET_BALANCE(P_ACCOUNT_ID NUMBER) RETURN NUMBER IS
  V_BAL NUMBER;
BEGIN
  SELECT NVL(SUM(AMOUNT),0) INTO V_BAL FROM FIN_LEDGER WHERE ACCOUNT_ID = P_ACCOUNT_ID;
  RETURN V_BAL;
END;
/
CREATE OR REPLACE PACKAGE PKG_FIN_RECON AS
  PROCEDURE RECONCILE_ACCOUNT(P_ACCOUNT_ID NUMBER);
END PKG_FIN_RECON;
/

-- LAB_APP
ALTER SESSION SET CURRENT_SCHEMA = LAB_APP;
CREATE OR REPLACE FUNCTION FN_ORDER_TOTAL(P_ORDER_ID NUMBER) RETURN NUMBER IS
  V_SUM NUMBER;
BEGIN
  SELECT NVL(SUM(QTY * UNIT_PRICE),0) INTO V_SUM FROM APP_ORDER_LINE WHERE ORDER_ID = P_ORDER_ID;
  RETURN V_SUM;
END;
/
CREATE OR REPLACE VIEW V_ORDER_SUM AS
SELECT o.ORDER_ID, o.ORDER_CODE, o.CHANNEL, c.NAME AS ACCOUNT_NAME, FN_ORDER_TOTAL(o.ORDER_ID) AS ORDER_TOTAL
  FROM APP_ORDER o
  JOIN LAB_CORE.CORE_ACCOUNT c ON c.ACCOUNT_ID = o.ACCOUNT_ID;
  
CREATE OR REPLACE PACKAGE PKG_APP_API AS
  FUNCTION ORDER_WITH_BALANCE(P_ORDER_ID NUMBER) RETURN NUMBER;
  PROCEDURE RAISE_IF_OVERDUE(P_ORDER_ID NUMBER);
END PKG_APP_API;
/

-- LAB_UTIL
ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
GRANT EXECUTE ON FN_GET_BALANCE TO LAB_UTIL;

ALTER SESSION SET CURRENT_SCHEMA = LAB_APP;
GRANT SELECT ON V_ORDER_SUM TO LAB_UTIL;

ALTER SESSION SET CURRENT_SCHEMA = LAB_UTIL;
CREATE OR REPLACE SYNONYM SYN_FN_BALANCE FOR LAB_FIN.FN_GET_BALANCE;
CREATE OR REPLACE SYNONYM SYN_ORDER_VIEW FOR LAB_APP.V_ORDER_SUM;
CREATE OR REPLACE PROCEDURE PR_LOG_ACTIVITY(P_TAG VARCHAR2, P_DETAILS VARCHAR2) AS
BEGIN
  INSERT INTO UTIL_LOG(TAG, DETAILS) VALUES (P_TAG, P_DETAILS);
END;
/
CREATE OR REPLACE FUNCTION FN_LOG_AND_BALANCE(P_ACCOUNT_ID NUMBER) RETURN NUMBER AS
  V_BAL NUMBER;
BEGIN
  V_BAL := SYN_FN_BALANCE(P_ACCOUNT_ID);
  PR_LOG_ACTIVITY('BAL', 'Balance='||V_BAL);
  RETURN V_BAL;
END;
/

--------------------------------------------------------------------------------
-- 6) 阶段四：授予 PL/SQL 执行权限
--------------------------------------------------------------------------------
PROMPT --- Granting PL/SQL permissions ---;
ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
GRANT EXECUTE ON FN_GET_BALANCE TO LAB_CORE;
GRANT EXECUTE ON FN_GET_BALANCE TO LAB_APP;

ALTER SESSION SET CURRENT_SCHEMA = LAB_CORE;
GRANT EXECUTE ON PKG_CORE_UTIL TO LAB_FIN;

--------------------------------------------------------------------------------
-- 7) 阶段五：创建 Package Bodies 和 Triggers
--------------------------------------------------------------------------------
PROMPT --- Creating Package Bodies and Triggers ---;
-- LAB_CORE
ALTER SESSION SET CURRENT_SCHEMA = LAB_CORE;
CREATE OR REPLACE PACKAGE BODY PKG_CORE_UTIL AS
  FUNCTION ACCOUNT_LABEL(P_ACCOUNT_ID NUMBER) RETURN VARCHAR2 IS
    V_NAME   CORE_ACCOUNT.NAME%TYPE;
    V_STATUS CORE_ACCOUNT.STATUS%TYPE;
  BEGIN
    SELECT NAME, STATUS INTO V_NAME, V_STATUS
      FROM CORE_ACCOUNT WHERE ACCOUNT_ID = P_ACCOUNT_ID;
    RETURN T_AUDIT_TAG(V_STATUS).TO_LABEL || V_NAME;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN '[UNKNOWN]' || P_ACCOUNT_ID;
  END;

  PROCEDURE REFRESH_STATUS(P_ACCOUNT_ID NUMBER) IS
  BEGIN
    -- 引入跨 schema 依赖：调用 LAB_FIN.FN_GET_BALANCE
    DECLARE
      V_BAL NUMBER := LAB_FIN.FN_GET_BALANCE(P_ACCOUNT_ID);
    BEGIN
      IF V_BAL < 0 THEN
        UPDATE CORE_ACCOUNT SET STATUS = 'SUSPENDED' WHERE ACCOUNT_ID = P_ACCOUNT_ID;
      ELSE
        UPDATE CORE_ACCOUNT SET STATUS = 'ACTIVE' WHERE ACCOUNT_ID = P_ACCOUNT_ID;
      END IF;
    END;
  END;
END PKG_CORE_UTIL;
/
CREATE OR REPLACE TRIGGER TRG_ACCOUNT_BI
BEFORE INSERT ON CORE_ACCOUNT
FOR EACH ROW
BEGIN
  IF :NEW.ACCOUNT_ID IS NULL THEN
    SELECT SEQ_ACCOUNT.NEXTVAL INTO :NEW.ACCOUNT_ID FROM dual;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSDATE);
END;
/
CREATE OR REPLACE PROCEDURE PR_REFRESH_STATUS(P_ACCOUNT_ID NUMBER) AS
BEGIN
  PKG_CORE_UTIL.REFRESH_STATUS(P_ACCOUNT_ID);
END;
/

-- LAB_FIN
ALTER SESSION SET CURRENT_SCHEMA = LAB_FIN;
CREATE OR REPLACE PACKAGE BODY PKG_FIN_RECON AS
  PROCEDURE RECONCILE_ACCOUNT(P_ACCOUNT_ID NUMBER) IS
    V_BAL NUMBER := FN_GET_BALANCE(P_ACCOUNT_ID);
    V_LABEL VARCHAR2(200);
  BEGIN
    V_LABEL := LAB_CORE.PKG_CORE_UTIL.ACCOUNT_LABEL(P_ACCOUNT_ID);
    INSERT INTO FIN_LEDGER(LEDGER_ID, ACCOUNT_ID, AMOUNT, CURRENCY, REMARK)
      VALUES (SEQ_LEDGER.NEXTVAL, P_ACCOUNT_ID, -1, 'CNY', 'RECON:'||V_LABEL||':'||V_BAL);
  END;
END PKG_FIN_RECON;
/
CREATE OR REPLACE TRIGGER TRG_LEDGER_BI
BEFORE INSERT ON FIN_LEDGER
FOR EACH ROW
BEGIN
  IF :NEW.LEDGER_ID IS NULL THEN
    SELECT SEQ_LEDGER.NEXTVAL INTO :NEW.LEDGER_ID FROM dual;
  END IF;
END;
/

-- LAB_APP
ALTER SESSION SET CURRENT_SCHEMA = LAB_APP;
CREATE OR REPLACE PACKAGE BODY PKG_APP_API AS
  FUNCTION ORDER_WITH_BALANCE(P_ORDER_ID NUMBER) RETURN NUMBER IS
    V_ACCT NUMBER;
  BEGIN
    SELECT ACCOUNT_ID INTO V_ACCT FROM APP_ORDER WHERE ORDER_ID = P_ORDER_ID;
    RETURN FN_ORDER_TOTAL(P_ORDER_ID) + LAB_FIN.FN_GET_BALANCE(V_ACCT);
  END;

  PROCEDURE RAISE_IF_OVERDUE(P_ORDER_ID NUMBER) IS
    V_ACCOUNT NUMBER;
    V_BAL NUMBER;
  BEGIN
    SELECT ACCOUNT_ID INTO V_ACCOUNT FROM APP_ORDER WHERE ORDER_ID = P_ORDER_ID;
    V_BAL := LAB_FIN.FN_GET_BALANCE(V_ACCOUNT);
    IF V_BAL < -100 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Overdue customer');
    END IF;
  END;
END PKG_APP_API;
/
CREATE OR REPLACE TRIGGER TRG_ORDER_BI
BEFORE INSERT ON APP_ORDER
FOR EACH ROW
BEGIN
  IF :NEW.ORDER_ID IS NULL THEN
    SELECT SEQ_ORDER.NEXTVAL INTO :NEW.ORDER_ID FROM dual;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSDATE);
END;
/
CREATE OR REPLACE PROCEDURE PR_CREATE_ORDER(
  P_ACCOUNT_ID NUMBER,
  P_ORDER_CODE VARCHAR2,
  P_CHANNEL    VARCHAR2
) AS
  V_ORDER_ID NUMBER;
BEGIN
  V_ORDER_ID := SEQ_ORDER.NEXTVAL;
  INSERT INTO APP_ORDER(ORDER_ID, ACCOUNT_ID, ORDER_CODE, CHANNEL)
    VALUES (V_ORDER_ID, P_ACCOUNT_ID, P_ORDER_CODE, P_CHANNEL);
  INSERT INTO APP_ORDER_LINE(ORDER_LINE_ID, ORDER_ID, SKU, QTY, UNIT_PRICE)
    VALUES (SEQ_ORDER_LINE.NEXTVAL, V_ORDER_ID, 'SKU-DEMO', 1, 99);
END;
/

-- LAB_UTIL
ALTER SESSION SET CURRENT_SCHEMA = LAB_UTIL;
CREATE OR REPLACE TRIGGER TRG_LOG_BI
BEFORE INSERT ON UTIL_LOG
FOR EACH ROW
BEGIN
  IF :NEW.LOG_ID IS NULL THEN
    SELECT SEQ_LOG.NEXTVAL INTO :NEW.LOG_ID FROM dual;
  END IF;
END;
/

--------------------------------------------------------------------------------
-- 8) 阶段六：插入测试数据
--------------------------------------------------------------------------------
PROMPT --- Inserting test data ---;
INSERT INTO LAB_CORE.CORE_ACCOUNT(ACCOUNT_ID, NAME, STATUS, REGION_CODE, CREATED_AT) VALUES (1, 'Starter', 'ACTIVE', 'CN-N', SYSDATE);
INSERT INTO LAB_FIN.FIN_LEDGER(LEDGER_ID, ACCOUNT_ID, AMOUNT, CURRENCY) VALUES (5001, 1, 50, 'CNY');
INSERT INTO LAB_APP.APP_ORDER(ORDER_ID, ACCOUNT_ID, ORDER_CODE, CHANNEL) VALUES (20001, 1, 'ORD-1', 'WEB');
INSERT INTO LAB_APP.APP_ORDER_LINE(ORDER_LINE_ID, ORDER_ID, SKU, QTY, UNIT_PRICE) VALUES (90001, 20001, 'SKU-DEMO', 2, 10);

COMMIT;

--------------------------------------------------------------------------------
-- 9) 最终修复步骤：重新编译所有无效的对象 (安全保障)
--------------------------------------------------------------------------------
SET SERVEROUTPUT ON;
DECLARE
  V_STMT VARCHAR2(300);
BEGIN
  DBMS_OUTPUT.PUT_LINE('--- Recompiling invalid objects ---');
  FOR I IN (
    SELECT OWNER, OBJECT_NAME, OBJECT_TYPE
    FROM ALL_OBJECTS
    WHERE OWNER IN ('LAB_CORE', 'LAB_FIN', 'LAB_APP', 'LAB_UTIL')
    AND STATUS = 'INVALID'
    ORDER BY DECODE(OBJECT_TYPE, 'PACKAGE', 1, 'VIEW', 2, 'PACKAGE BODY', 3, 4)
  )
  LOOP
    BEGIN
      IF I.OBJECT_TYPE = 'PACKAGE BODY' THEN
        V_STMT := 'ALTER PACKAGE "'||I.OWNER||'"."'||I.OBJECT_NAME||'" COMPILE BODY';
      ELSE
        V_STMT := 'ALTER '||I.OBJECT_TYPE||' "'||I.OWNER||'"."'||I.OBJECT_NAME||'" COMPILE';
      END IF;
      
      DBMS_OUTPUT.PUT_LINE('Executing: ' || V_STMT);
      EXECUTE IMMEDIATE V_STMT;
      
    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  -> Failed to compile ' || I.OBJECT_TYPE || ' "' || I.OWNER || '"."' || I.OBJECT_NAME || '" - Error: ' || SQLERRM);
    END;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('--- Recompilation finished ---');
END;
/
