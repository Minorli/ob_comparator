-- Spiderweb remap source-side DDL (Oracle)
-- Run as a privileged user. Adjust tablespace names or quotas as needed.
SET DEFINE OFF;
WHENEVER SQLERROR EXIT FAILURE;

PROMPT === Creating source schemas ===

CREATE USER ORA_SALES IDENTIFIED BY ora_sales_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER, CREATE SYNONYM TO ORA_SALES;

CREATE USER ORA_REF IDENTIFIED BY ora_ref_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_REF;

CREATE USER ORA_LOG IDENTIFIED BY ora_log_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_LOG;

CREATE USER ORA_UTIL IDENTIFIED BY ora_util_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE TRIGGER, CREATE SYNONYM TO ORA_UTIL;

CREATE USER ORA_SEC IDENTIFIED BY ora_sec_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW TO ORA_SEC;

PROMPT === ORA_REF lookup tables ===

CREATE TABLE ORA_REF.REGION_DIM (
    REGION_ID     NUMBER(6),
    REGION_CODE   VARCHAR2(20)    NOT NULL,
    REGION_NAME   VARCHAR2(100)   NOT NULL,
    ACTIVE_FLAG   VARCHAR2(1)     DEFAULT 'Y' NOT NULL,
    CREATED_AT    DATE            DEFAULT SYSDATE NOT NULL,
    CONSTRAINT PK_REGION_DIM PRIMARY KEY (REGION_ID),
    CONSTRAINT UK_REGION_DIM_CODE UNIQUE (REGION_CODE)
);

CREATE SEQUENCE ORA_REF.SEQ_REGION START WITH 1 INCREMENT BY 1 CACHE 50;

CREATE TABLE ORA_REF.SHIP_METHOD (
    SHIP_METHOD_ID    NUMBER(4),
    SHIP_METHOD_CODE  VARCHAR2(20) NOT NULL,
    SHIP_METHOD_NAME  VARCHAR2(80) NOT NULL,
    REGION_ID         NUMBER(6) NOT NULL,
    CONSTRAINT PK_SHIP_METHOD PRIMARY KEY (SHIP_METHOD_ID),
    CONSTRAINT FK_SHIP_METHOD_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID)
);

CREATE INDEX ORA_REF.IDX_SHIP_METHOD_REGION ON ORA_REF.SHIP_METHOD(REGION_ID);

PROMPT === ORA_SALES dimensional + fact tables ===

CREATE TABLE ORA_SALES.CUSTOMER_DIM (
    CUSTOMER_ID    NUMBER(10)                             CONSTRAINT PK_CUSTOMER_DIM PRIMARY KEY,
    CUSTOMER_CODE  VARCHAR2(30)  NOT NULL,
    CUSTOMER_NAME  VARCHAR2(120) NOT NULL,
    EMAIL          VARCHAR2(180),
    STATUS         VARCHAR2(1)   DEFAULT 'A' NOT NULL,
    VIP_FLAG       VARCHAR2(1)   DEFAULT 'N',
    REGION_ID      NUMBER(6)     NOT NULL,
    CREDIT_LIMIT   NUMBER(12,2),
    CREATED_AT     DATE          DEFAULT SYSDATE NOT NULL,
    UPDATED_AT     DATE,
    CONSTRAINT UK_CUSTOMER_DIM_CODE UNIQUE (CUSTOMER_CODE),
    CONSTRAINT FK_CUSTOMER_DIM_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID)
);

CREATE TABLE ORA_SALES.ORDER_FACT (
    ORDER_ID        NUMBER(12),
    ORDER_CODE      VARCHAR2(40),
    CUSTOMER_ID     NUMBER(10) NOT NULL,
    SHIP_METHOD_ID  NUMBER(4)  NOT NULL,
    ORDER_TOTAL     NUMBER(14,2),
    DISCOUNT_RATE   NUMBER(5,2),
    STATUS          VARCHAR2(1) DEFAULT 'N' NOT NULL,
    ORDER_NOTE      VARCHAR2(400),
    CREATED_AT      DATE DEFAULT SYSDATE,
    UPDATED_AT      DATE,
    CONSTRAINT PK_ORDER_FACT PRIMARY KEY (ORDER_ID),
    CONSTRAINT FK_ORDER_FACT_CUSTOMER FOREIGN KEY (CUSTOMER_ID)
        REFERENCES ORA_SALES.CUSTOMER_DIM(CUSTOMER_ID),
    CONSTRAINT FK_ORDER_FACT_SHIP FOREIGN KEY (SHIP_METHOD_ID)
        REFERENCES ORA_REF.SHIP_METHOD(SHIP_METHOD_ID),
    CONSTRAINT CK_ORDER_FACT_STATUS CHECK (STATUS IN ('N','P','C'))
);

CREATE INDEX ORA_SALES.IDX_ORDER_FACT_CUST_DT ON ORA_SALES.ORDER_FACT(CUSTOMER_ID, CREATED_AT);
CREATE UNIQUE INDEX ORA_SALES.UK_ORDER_FACT_CODE ON ORA_SALES.ORDER_FACT(ORDER_CODE);

CREATE SEQUENCE ORA_SALES.SEQ_CUSTOMER START WITH 1000 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ORA_SALES.SEQ_ORDER     START WITH 50000 INCREMENT BY 5;

CREATE OR REPLACE TRIGGER ORA_SALES.TRG_ORDER_FACT_BI
BEFORE INSERT ON ORA_SALES.ORDER_FACT
FOR EACH ROW
BEGIN
    IF :NEW.ORDER_ID IS NULL THEN
        SELECT ORA_SALES.SEQ_ORDER.NEXTVAL INTO :NEW.ORDER_ID FROM DUAL;
    END IF;
    IF :NEW.ORDER_CODE IS NULL THEN
        :NEW.ORDER_CODE := 'ORD-' || TO_CHAR(ORA_SALES.SEQ_ORDER.NEXTVAL);
    END IF;
END;
/

CREATE OR REPLACE VIEW ORA_SALES.VW_HOT_CUSTOMERS AS
SELECT c.CUSTOMER_ID,
       c.CUSTOMER_NAME,
       c.STATUS,
       SUM(o.ORDER_TOTAL) AS TOTAL_SALES
  FROM ORA_SALES.CUSTOMER_DIM c
  JOIN ORA_SALES.ORDER_FACT o ON o.CUSTOMER_ID = c.CUSTOMER_ID
 WHERE o.STATUS = 'C'
 GROUP BY c.CUSTOMER_ID, c.CUSTOMER_NAME, c.STATUS;

CREATE OR REPLACE PROCEDURE ORA_SALES.SP_CREATE_ORDER (
    p_customer_code IN VARCHAR2,
    p_ship_method   IN VARCHAR2,
    p_amount        IN NUMBER,
    p_discount      IN NUMBER
) AS
    v_cust_id NUMBER;
    v_ship_id NUMBER;
BEGIN
    SELECT CUSTOMER_ID INTO v_cust_id FROM ORA_SALES.CUSTOMER_DIM
     WHERE CUSTOMER_CODE = p_customer_code;

    SELECT SHIP_METHOD_ID INTO v_ship_id FROM ORA_REF.SHIP_METHOD
     WHERE SHIP_METHOD_CODE = p_ship_method;

    INSERT INTO ORA_SALES.ORDER_FACT (
        ORDER_ID, ORDER_CODE, CUSTOMER_ID, SHIP_METHOD_ID,
        ORDER_TOTAL, DISCOUNT_RATE, STATUS, ORDER_NOTE
    )
    VALUES (
        ORA_SALES.SEQ_ORDER.NEXTVAL,
        'ORD-' || TO_CHAR(ORA_SALES.SEQ_ORDER.CURRVAL),
        v_cust_id,
        v_ship_id,
        p_amount,
        p_discount,
        'N',
        'Created via SP_CREATE_ORDER'
    );
END;
/

CREATE OR REPLACE FUNCTION ORA_SALES.FN_CUSTOMER_SCORE (
    p_customer_id IN NUMBER
) RETURN NUMBER IS
    v_score NUMBER;
BEGIN
    SELECT NVL(SUM(ORDER_TOTAL), 0) INTO v_score
      FROM ORA_SALES.ORDER_FACT
     WHERE CUSTOMER_ID = p_customer_id
       AND STATUS = 'C';
    RETURN v_score;
END;
/

CREATE OR REPLACE PACKAGE ORA_SALES.PKG_ORDER_MGMT AS
    PROCEDURE QUEUE_ORDER(p_order_id NUMBER, p_status VARCHAR2);
    PROCEDURE CLOSE_ORDER(p_order_id NUMBER);
    FUNCTION COUNT_BY_STATUS(p_status VARCHAR2) RETURN NUMBER;
END PKG_ORDER_MGMT;
/

CREATE OR REPLACE PACKAGE BODY ORA_SALES.PKG_ORDER_MGMT AS
    PROCEDURE QUEUE_ORDER(p_order_id NUMBER, p_status VARCHAR2) IS
    BEGIN
        UPDATE ORA_SALES.ORDER_FACT
           SET STATUS = p_status,
               UPDATED_AT = SYSDATE
         WHERE ORDER_ID = p_order_id;
    END;

    PROCEDURE CLOSE_ORDER(p_order_id NUMBER) IS
    BEGIN
        UPDATE ORA_SALES.ORDER_FACT
           SET STATUS = 'C',
               UPDATED_AT = SYSDATE
         WHERE ORDER_ID = p_order_id;
    END;

    FUNCTION COUNT_BY_STATUS(p_status VARCHAR2) RETURN NUMBER IS
        v_cnt NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_cnt
          FROM ORA_SALES.ORDER_FACT
         WHERE STATUS = p_status;
        RETURN v_cnt;
    END;
END PKG_ORDER_MGMT;
/

PROMPT === ORA_LOG auditing objects ===

CREATE TABLE ORA_LOG.AUDIT_EVENTS (
    EVENT_ID       NUMBER(12),
    SOURCE_SCHEMA  VARCHAR2(30)  NOT NULL,
    OBJECT_NAME    VARCHAR2(50)  NOT NULL,
    EVENT_TYPE     VARCHAR2(20)  NOT NULL,
    EVENT_TS       DATE          DEFAULT SYSDATE,
    DETAIL         VARCHAR2(2000),
    CONSTRAINT PK_AUDIT_EVENTS PRIMARY KEY (EVENT_ID)
);

CREATE TABLE ORA_LOG.AUDIT_ARCHIVE AS
SELECT * FROM ORA_LOG.AUDIT_EVENTS WHERE 1 = 2;

CREATE TABLE ORA_LOG.ERROR_LOG (
    ERROR_ID      NUMBER(12),
    ERROR_CODE    VARCHAR2(20) NOT NULL,
    ERROR_MESSAGE VARCHAR2(400),
    CREATED_BY    VARCHAR2(30),
    CREATED_AT    DATE DEFAULT SYSDATE,
    CONSTRAINT PK_ERROR_LOG PRIMARY KEY (ERROR_ID)
);

CREATE INDEX ORA_LOG.IDX_ERROR_LOG_CODE ON ORA_LOG.ERROR_LOG(ERROR_CODE);

CREATE SEQUENCE ORA_LOG.SEQ_AUDIT START WITH 10 INCREMENT BY 1;
CREATE SEQUENCE ORA_LOG.SEQ_ERROR START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER ORA_LOG.TRG_AUDIT_EVENTS_BI
BEFORE INSERT ON ORA_LOG.AUDIT_EVENTS
FOR EACH ROW
BEGIN
    IF :NEW.EVENT_ID IS NULL THEN
        SELECT ORA_LOG.SEQ_AUDIT.NEXTVAL INTO :NEW.EVENT_ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE ORA_LOG.SP_ARCHIVE_AUDIT (
    p_cleanup_days IN NUMBER
) AS
BEGIN
    INSERT INTO ORA_LOG.AUDIT_ARCHIVE
    SELECT *
      FROM ORA_LOG.AUDIT_EVENTS
     WHERE EVENT_TS < SYSDATE - p_cleanup_days;
END;
/

CREATE OR REPLACE FUNCTION ORA_LOG.FN_LAST_AUDIT_ID RETURN NUMBER IS
    v_id NUMBER;
BEGIN
    SELECT NVL(MAX(EVENT_ID), 0) INTO v_id FROM ORA_LOG.AUDIT_EVENTS;
    RETURN v_id;
END;
/

PROMPT === ORA_UTIL shared synonyms and reporting objects ===

CREATE SYNONYM ORA_UTIL.SYN_CUSTOMER FOR ORA_SALES.CUSTOMER_DIM;
CREATE SYNONYM ORA_UTIL.SYN_ORDER    FOR ORA_SALES.ORDER_FACT;
CREATE SYNONYM ORA_UTIL.SYN_REGION   FOR ORA_REF.REGION_DIM;

CREATE OR REPLACE VIEW ORA_UTIL.VW_CUSTOMER_REGION AS
SELECT c.CUSTOMER_ID,
       c.CUSTOMER_NAME,
       r.REGION_CODE,
       r.REGION_NAME,
       COUNT(o.ORDER_ID) AS ORDER_CNT,
       NVL(SUM(o.ORDER_TOTAL),0) AS TOTAL_SALES
  FROM ORA_UTIL.SYN_CUSTOMER c
  LEFT JOIN ORA_UTIL.SYN_REGION r ON r.REGION_ID = c.REGION_ID
  LEFT JOIN ORA_UTIL.SYN_ORDER o ON o.CUSTOMER_ID = c.CUSTOMER_ID
 GROUP BY c.CUSTOMER_ID, c.CUSTOMER_NAME, r.REGION_CODE, r.REGION_NAME;

CREATE OR REPLACE PACKAGE ORA_UTIL.PKG_DATA_ROUTER AS
    PROCEDURE REFRESH_REGION_CACHE;
    FUNCTION COUNT_ORDERS_BY_REGION(p_region_code VARCHAR2) RETURN NUMBER;
END PKG_DATA_ROUTER;
/

CREATE OR REPLACE PACKAGE BODY ORA_UTIL.PKG_DATA_ROUTER AS
    PROCEDURE REFRESH_REGION_CACHE IS
    BEGIN
        NULL;
    END;

    FUNCTION COUNT_ORDERS_BY_REGION(p_region_code VARCHAR2) RETURN NUMBER IS
        v_cnt NUMBER;
    BEGIN
        SELECT COUNT(*)
          INTO v_cnt
          FROM ORA_UTIL.SYN_ORDER o
          JOIN ORA_UTIL.SYN_CUSTOMER c ON c.CUSTOMER_ID = o.CUSTOMER_ID
          JOIN ORA_UTIL.SYN_REGION r ON r.REGION_ID = c.REGION_ID
         WHERE r.REGION_CODE = p_region_code;
        RETURN v_cnt;
    END;
END PKG_DATA_ROUTER;
/

PROMPT === ORA_SEC (non-remapped) control objects ===

CREATE TABLE ORA_SEC.USER_MATRIX (
    USERNAME      VARCHAR2(60)  NOT NULL,
    LAST_LOGIN    DATE,
    STATUS        VARCHAR2(20)  NOT NULL,
    ATTEMPTS      NUMBER(3)     DEFAULT 0,
    LOCK_REASON   VARCHAR2(200),
    CONSTRAINT PK_USER_MATRIX PRIMARY KEY (USERNAME)
);

CREATE OR REPLACE VIEW ORA_SEC.VW_LOGIN_FAILURE AS
SELECT USERNAME, LAST_LOGIN, STATUS, ATTEMPTS
  FROM ORA_SEC.USER_MATRIX
 WHERE STATUS = 'LOCKED';

PROMPT === Source side definition complete ===
COMMIT;
