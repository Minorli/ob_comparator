# 依附对象父表映射修复说明 (v0.8.4)

## 问题背景

在审核remap逻辑时发现，`get_object_parent_tables()` 函数只处理了TRIGGER，没有处理INDEX/CONSTRAINT/SEQUENCE。

这导致在**一对多场景**下（如 MONSTER_A → TITAN_A + TITAN_B），这些依附对象无法正确跟随父表的remap。

## 问题示例

### 场景：一对多拆分

```
Remap规则:
  MONSTER_A.DUNGEONS = TITAN_A.DUNGEON_INFO
  MONSTER_A.LAIRS = TITAN_B.LAIR_INFO

依附对象:
  MONSTER_A.IDX_DUNGEON_LEVEL (索引，属于 DUNGEONS 表)
  MONSTER_A.PK_DUNGEONS (约束，属于 DUNGEONS 表)
  MONSTER_A.SEQ_DUNGEON_ID (序列，被 DUNGEONS 表使用)
```

### 修复前的行为

```
1. object_parent_map 中没有索引/约束/序列的父表映射
2. 尝试依赖分析推导 -> 失败（这些对象不在 DBA_DEPENDENCIES 中）
3. 尝试schema映射推导 -> 失败（MONSTER_A 映射到多个schema）
4. 回退到 1:1 映射 -> MONSTER_A.IDX_DUNGEON_LEVEL (错误！)

结果: 所有依附对象都被错误地映射到 MONSTER_A schema
```

### 修复后的行为

```
1. object_parent_map 中有完整的父表映射:
   - MONSTER_A.IDX_DUNGEON_LEVEL -> MONSTER_A.DUNGEONS
   - MONSTER_A.PK_DUNGEONS -> MONSTER_A.DUNGEONS
   - MONSTER_A.SEQ_DUNGEON_ID -> MONSTER_A.DUNGEONS

2. 查找父表的remap目标:
   - MONSTER_A.DUNGEONS -> TITAN_A.DUNGEON_INFO

3. 使用父表的目标schema:
   - MONSTER_A.IDX_DUNGEON_LEVEL -> TITAN_A.IDX_DUNGEON_LEVEL ✓
   - MONSTER_A.PK_DUNGEONS -> TITAN_A.PK_DUNGEONS ✓
   - MONSTER_A.SEQ_DUNGEON_ID -> TITAN_A.SEQ_DUNGEON_ID ✓

结果: 所有依附对象正确跟随父表到 TITAN_A schema
```

## 修复内容

### 1. 扩展 TRIGGER 映射（已有）

```sql
SELECT OWNER, TRIGGER_NAME, TABLE_OWNER, TABLE_NAME
FROM DBA_TRIGGERS
WHERE OWNER IN (源schema列表)
  AND TABLE_NAME IS NOT NULL
  AND BASE_OBJECT_TYPE IN ('TABLE', 'VIEW')
```

**结果**: `{SCHEMA.TRIGGER_NAME: SCHEMA.TABLE_NAME}`

### 2. 新增 INDEX 映射

```sql
SELECT OWNER, INDEX_NAME, TABLE_OWNER, TABLE_NAME
FROM DBA_INDEXES
WHERE OWNER IN (源schema列表)
  AND TABLE_NAME IS NOT NULL
```

**结果**: `{SCHEMA.INDEX_NAME: SCHEMA.TABLE_NAME}`

### 3. 新增 CONSTRAINT 映射

```sql
SELECT OWNER, CONSTRAINT_NAME, TABLE_NAME
FROM DBA_CONSTRAINTS
WHERE OWNER IN (源schema列表)
  AND TABLE_NAME IS NOT NULL
```

**结果**: `{SCHEMA.CONSTRAINT_NAME: SCHEMA.TABLE_NAME}`

### 4. 新增 SEQUENCE 映射（智能推导）

**方法**: 分析触发器代码中的序列使用

```sql
SELECT t.OWNER, t.TRIGGER_NAME, t.TABLE_OWNER, t.TABLE_NAME, t.TRIGGER_BODY
FROM DBA_TRIGGERS t
WHERE t.OWNER IN (源schema列表)
  AND t.TABLE_NAME IS NOT NULL
  AND t.TRIGGER_BODY IS NOT NULL
  AND UPPER(t.TRIGGER_BODY) LIKE '%.NEXTVAL%'
```

**分析逻辑**:
```python
# 使用正则表达式匹配序列引用
seq_pattern = r'(?:(\w+)\.)?(\w+)\.NEXTVAL'

# 示例匹配:
# "SEQ_DUNGEON_ID.NEXTVAL" -> (None, "SEQ_DUNGEON_ID")
# "MONSTER_A.SEQ_DUNGEON_ID.NEXTVAL" -> ("MONSTER_A", "SEQ_DUNGEON_ID")
```

**结果**: `{SCHEMA.SEQUENCE_NAME: SCHEMA.TABLE_NAME}`

## 使用场景

### 场景1: 多对一（已支持，现在更完善）

```
Remap规则:
  HERO_A.USERS = OLYMPIAN_A.USERS
  HERO_B.USERS = OLYMPIAN_A.USERS_B

依附对象:
  HERO_A.IDX_EMAIL -> OLYMPIAN_A.IDX_EMAIL ✓
  HERO_B.IDX_EMAIL -> OLYMPIAN_A.IDX_EMAIL (冲突检测会重命名)
```

### 场景2: 一对一（已支持，现在更完善）

```
Remap规则:
  GOD_A.DEITIES = PRIMORDIAL.DEITIES

依附对象:
  GOD_A.PK_DEITIES -> PRIMORDIAL.PK_DEITIES ✓
  GOD_A.SEQ_DEITY_ID -> PRIMORDIAL.SEQ_DEITY_ID ✓
```

### 场景3: 一对多（主要修复目标）

```
Remap规则:
  MONSTER_A.DUNGEONS = TITAN_A.DUNGEON_INFO
  MONSTER_A.LAIRS = TITAN_B.LAIR_INFO
  MONSTER_A.MINIONS = TITAN_A.MINIONS
  MONSTER_A.TREASURES = TITAN_B.TREASURES

依附对象:
  MONSTER_A.IDX_DUNGEON_LEVEL -> TITAN_A.IDX_DUNGEON_LEVEL ✓
  MONSTER_A.IDX_LAIR_SIZE -> TITAN_B.IDX_LAIR_SIZE ✓
  MONSTER_A.SEQ_DUNGEON_ID -> TITAN_A.SEQ_DUNGEON_ID ✓
  MONSTER_A.SEQ_LAIR_ID -> TITAN_B.SEQ_LAIR_ID ✓
```

## SEQUENCE推导的限制

### 可以推导的情况

1. **触发器中使用序列**:
```sql
CREATE TRIGGER TRG_DUNGEONS
BEFORE INSERT ON DUNGEONS
FOR EACH ROW
BEGIN
  SELECT SEQ_DUNGEON_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
```

2. **带schema前缀的序列**:
```sql
SELECT MONSTER_A.SEQ_DUNGEON_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
```

### 无法推导的情况

1. **列默认值中使用序列**:
```sql
CREATE TABLE DUNGEONS (
  ID NUMBER DEFAULT SEQ_DUNGEON_ID.NEXTVAL
);
```
**原因**: 当前未分析列默认值（可以在后续版本中添加）

2. **应用代码中使用序列**:
```sql
-- 在Java/Python代码中
SELECT SEQ_DUNGEON_ID.NEXTVAL FROM DUAL;
```
**原因**: 无法分析应用代码

3. **独立的序列**:
```sql
-- 不被任何表使用的序列
CREATE SEQUENCE SEQ_GLOBAL_COUNTER;
```
**原因**: 没有父表关联

### 对于无法推导的SEQUENCE

**建议**: 用户应该在remap规则中显式指定

```
# remap_rules.txt
MONSTER_A.SEQ_GLOBAL_COUNTER = TITAN_A.SEQ_GLOBAL_COUNTER
```

## DDL中的表名替换

**已有功能**: `adjust_ddl_for_object()` 函数会替换DDL中的表名引用

### 示例1: 触发器DDL

```sql
-- 源端DDL
CREATE TRIGGER MONSTER_A.TRG_DUNGEONS
BEFORE INSERT ON MONSTER_A.DUNGEONS
FOR EACH ROW
BEGIN
  SELECT MONSTER_A.SEQ_DUNGEON_ID.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

-- 替换后（目标: TITAN_A）
CREATE TRIGGER TITAN_A.TRG_DUNGEONS
BEFORE INSERT ON TITAN_A.DUNGEON_INFO  -- 表名已替换
FOR EACH ROW
BEGIN
  SELECT TITAN_A.SEQ_DUNGEON_ID.NEXTVAL INTO :NEW.ID FROM DUAL;  -- 序列名已替换
END;
```

### 示例2: 视图DDL

```sql
-- 源端DDL
CREATE VIEW MONSTER_A.VW_DUNGEON_STATS AS
SELECT D.ID, D.NAME, COUNT(M.ID) AS MINION_COUNT
FROM MONSTER_A.DUNGEONS D
LEFT JOIN MONSTER_A.MINIONS M ON D.ID = M.DUNGEON_ID
GROUP BY D.ID, D.NAME;

-- 替换后（目标: TITAN_A）
CREATE VIEW TITAN_A.VW_DUNGEON_STATS AS
SELECT D.ID, D.NAME, COUNT(M.ID) AS MINION_COUNT
FROM TITAN_A.DUNGEON_INFO D  -- 表名已替换
LEFT JOIN TITAN_A.MINIONS M ON D.ID = M.DUNGEON_ID  -- 表名已替换
GROUP BY D.ID, D.NAME;
```

### 示例3: 外键约束DDL

```sql
-- 源端DDL
ALTER TABLE MONSTER_A.MINIONS
ADD CONSTRAINT FK_MINION_DUNGEON
FOREIGN KEY (DUNGEON_ID)
REFERENCES MONSTER_A.DUNGEONS (ID);

-- 替换后（目标: TITAN_A）
ALTER TABLE TITAN_A.MINIONS
ADD CONSTRAINT FK_MINION_DUNGEON
FOREIGN KEY (DUNGEON_ID)
REFERENCES TITAN_A.DUNGEON_INFO (ID);  -- 引用表名已替换
```

## 验证方法

### 1. 检查日志

运行程序后，查找父表映射日志：

```
[INFO] 已获取 156 个依附对象的父表映射（TRIGGER/INDEX/CONSTRAINT/SEQUENCE）。
```

数量应该包含所有类型的依附对象。

### 2. 检查推导日志

查找依附对象的推导日志：

```bash
grep "使用父表的目标schema" main_reports/report_*.txt
```

应该看到INDEX/CONSTRAINT/SEQUENCE的推导信息。

### 3. 手工验证

查询Oracle端的依附对象：

```sql
-- 索引
SELECT OWNER, INDEX_NAME, TABLE_NAME
FROM DBA_INDEXES
WHERE OWNER = 'MONSTER_A'
ORDER BY TABLE_NAME, INDEX_NAME;

-- 约束
SELECT OWNER, CONSTRAINT_NAME, TABLE_NAME, CONSTRAINT_TYPE
FROM DBA_CONSTRAINTS
WHERE OWNER = 'MONSTER_A'
ORDER BY TABLE_NAME, CONSTRAINT_NAME;

-- 序列（通过触发器查找）
SELECT DISTINCT
  t.OWNER,
  REGEXP_SUBSTR(UPPER(t.TRIGGER_BODY), '(\w+)\.NEXTVAL', 1, LEVEL, NULL, 1) AS SEQ_NAME,
  t.TABLE_NAME
FROM DBA_TRIGGERS t
WHERE t.OWNER = 'MONSTER_A'
  AND UPPER(t.TRIGGER_BODY) LIKE '%.NEXTVAL%'
CONNECT BY LEVEL <= REGEXP_COUNT(UPPER(t.TRIGGER_BODY), '(\w+)\.NEXTVAL')
  AND PRIOR t.TRIGGER_NAME = t.TRIGGER_NAME
  AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;
```

## 性能影响

### 额外的查询

- DBA_INDEXES: 1次查询
- DBA_CONSTRAINTS: 1次查询  
- DBA_TRIGGERS (带TRIGGER_BODY): 1次查询

### 性能开销

- 典型场景（1000个对象）: < 2秒
- 大型场景（10000个对象）: < 10秒

**结论**: 性能影响可接受

## 相关文档

- [REMAP_LOGIC_AUDIT.md](REMAP_LOGIC_AUDIT.md) - Remap逻辑审核报告
- [REMAP_INFERENCE_GUIDE.md](REMAP_INFERENCE_GUIDE.md) - Remap推导指南
- [CHANGELOG.md](CHANGELOG.md) - 版本变更记录

## 总结

v0.8.4 版本完善了依附对象的父表映射，确保：

✅ **TRIGGER** 跟随父表  
✅ **INDEX** 跟随父表  
✅ **CONSTRAINT** 跟随父表  
✅ **SEQUENCE** 智能推导父表（基于触发器代码分析）

这个修复对**一对多场景**特别重要，确保所有依附对象都能正确跟随父表的remap。
